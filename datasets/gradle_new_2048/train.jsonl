{"label": "get|null|if|empty", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.util;\n\nimport static java.lang.Thread.currentThread;\nimport static java.util.concurrent.TimeUnit.SECONDS;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.sql.Connection;\nimport java.util.Locale;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.RejectedExecutionHandler;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic final class UtilityElf\n{\n   /**\n    * A constant for SQL Server's Snapshot isolation level\n    */\n   private static final int SQL_SERVER_SNAPSHOT_ISOLATION_LEVEL = 4096;\n\n   /**\n    *\n    * @return null if string is null or empty\n   */\n   public static String METHOD_NAME(final String text)\n   {\n      return text == null ? null : text.trim().isEmpty() ? null : text.trim();\n   }\n\n   /**\n    * Sleep and suppress InterruptedException (but re-signal it).\n    *\n    * @param millis the number of milliseconds to sleep\n    */\n   public static void quietlySleep(final long millis)\n   {\n      try {\n         Thread.sleep(millis);\n      }\n      catch (InterruptedException e) {\n         // I said be quiet!\n         currentThread().interrupt();\n      }\n   }\n\n   /**\n    * Create and instance of the specified class using the constructor matching the specified\n    * arguments.\n    *\n    * @param <T> the class type\n    * @param className the name of the class to instantiate\n    * @param clazz a class to cast the result as\n    * @param args arguments to a constructor\n    * @return an instance of the specified class\n    */\n   public static <T> T createInstance(final String className, final Class<T> clazz, final Object... args)\n   {\n      if (className == null) {\n         return null;\n      }\n\n      try {\n         Class<?> loaded = UtilityElf.class.getClassLoader().loadClass(className);\n         if (args.length == 0) {\n            return clazz.cast(loaded.newInstance());\n         }\n\n         Class<?>[] argClasses = new Class<?>[args.length];\n         for (int i = 0; i < args.length; i++) {\n            argClasses[i] = args[i].getClass();\n         }\n         Constructor<?> constructor = loaded.getConstructor(argClasses);\n         return clazz.cast(constructor.newInstance(args));\n      }\n      catch (Exception e) {\n         throw new RuntimeException(e);\n      }\n   }\n\n   /**\n    * Create a ThreadPoolExecutor.\n    *\n    * @param queueSize the queue size\n    * @param threadName the thread name\n    * @param threadFactory an optional ThreadFactory\n    * @param policy the RejectedExecutionHandler policy\n    * @return a ThreadPoolExecutor\n    */\n   public static ThreadPoolExecutor createThreadPoolExecutor(final int queueSize, final String threadName, ThreadFactory threadFactory, final RejectedExecutionHandler policy)\n   {\n      if (threadFactory == null) {\n         threadFactory = new DefaultThreadFactory(threadName, true);\n      }\n\n      LinkedBlockingQueue<Runnable> queue = new LinkedBlockingQueue<>(queueSize);\n      ThreadPoolExecutor executor = new ThreadPoolExecutor(1 /*core*/, 1 /*max*/, 5 /*keepalive*/, SECONDS, queue, threadFactory, policy);\n      executor.allowCoreThreadTimeOut(true);\n      return executor;\n   }\n\n   /**\n    * Create a ThreadPoolExecutor.\n    *\n    * @param queue the BlockingQueue to use\n    * @param threadName the thread name\n    * @param threadFactory an optional ThreadFactory\n    * @param policy the RejectedExecutionHandler policy\n    * @return a ThreadPoolExecutor\n    */\n   public static ThreadPoolExecutor createThreadPoolExecutor(final BlockingQueue<Runnable> queue, final String threadName, ThreadFactory threadFactory, final RejectedExecutionHandler policy)\n   {\n      if (threadFactory == null) {\n         threadFactory = new DefaultThreadFactory(threadName, true);\n      }\n\n      ThreadPoolExecutor executor = new ThreadPoolExecutor(1 /*core*/, 1 /*max*/, 5 /*keepalive*/, SECONDS, queue, threadFactory, policy);\n      executor.allowCoreThreadTimeOut(true);\n      return executor;\n   }\n\n   // ***********************************************************************\n   //                       Misc. public methods\n   // ***********************************************************************\n\n   /**\n    * Get the int value of a transaction isolation level by name.\n    *\n    * @param transactionIsolationName the name of the transaction isolation level\n    * @return the int value of the isolation level or -1\n    */\n   public static int getTransactionIsolation(final String transactionIsolationName)\n   {\n      if (transactionIsolationName != null) {\n         try {\n            // use the english locale to avoid the infamous turkish locale bug\n            final String upperName = transactionIsolationName.toUpperCase(Locale.ENGLISH);\n            if (upperName.startsWith(\"TRANSACTION_\")) {\n               Field field = Connection.class.getField(upperName);\n               return field.getInt(null);\n            }\n            final int level = Integer.parseInt(transactionIsolationName);\n            switch (level) {\n               case Connection.TRANSACTION_READ_UNCOMMITTED:\n               case Connection.TRANSACTION_READ_COMMITTED:\n               case Connection.TRANSACTION_REPEATABLE_READ:\n               case Connection.TRANSACTION_SERIALIZABLE:\n               case Connection.TRANSACTION_NONE:\n               case SQL_SERVER_SNAPSHOT_ISOLATION_LEVEL: // a specific isolation level for SQL server only\n                  return level;\n               default:\n                  throw new IllegalArgumentException();\n             }\n         }\n         catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid transaction isolation value: \" + transactionIsolationName);\n         }\n      }\n\n      return -1;\n   }\n\n   public static final class DefaultThreadFactory implements ThreadFactory {\n\n      private final String threadName;\n      private final boolean daemon;\n\n      public DefaultThreadFactory(String threadName, boolean daemon) {\n         this.threadName = threadName;\n         this.daemon = daemon;\n      }\n\n      @Override\n      public Thread newThread(Runnable r) {\n         Thread thread = new Thread(r, threadName);\n         thread.setDaemon(daemon);\n         return thread;\n      }\n   }\n}\n"}
{"label": "acquire", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.util;\n\nimport java.util.concurrent.Semaphore;\n\n/**\n * This class implements a lock that can be used to suspend and resume the pool.  It\n * also provides a faux implementation that is used when the feature is disabled that\n * hopefully gets fully \"optimized away\" by the JIT.\n *\n * @author Brett Wooldridge\n */\npublic class SuspendResumeLock\n{\n   public static final SuspendResumeLock FAUX_LOCK = new SuspendResumeLock(false) {\n      @Override\n      public void METHOD_NAME() {}\n\n      @Override\n      public void release() {}\n      \n      @Override\n      public void suspend() {}\n\n      @Override\n      public void resume() {}\n   };\n\n   private static final int MAX_PERMITS = 10000;\n   private final Semaphore acquisitionSemaphore;\n\n   /**\n    * Default constructor\n    */\n   public SuspendResumeLock()\n   {\n      this(true);\n   }\n\n   private SuspendResumeLock(final boolean createSemaphore)\n   {\n      acquisitionSemaphore = (createSemaphore ? new Semaphore(MAX_PERMITS, true) : null);\n   }\n\n   public void METHOD_NAME()\n   {\n      acquisitionSemaphore.acquireUninterruptibly();\n   }\n\n   public void release()\n   {\n      acquisitionSemaphore.release();\n   }\n\n   public void suspend()\n   {\n      acquisitionSemaphore.acquireUninterruptibly(MAX_PERMITS);\n   }\n\n   public void resume()\n   {\n      acquisitionSemaphore.release(MAX_PERMITS);\n   }\n}\n"}
{"label": "set|target|from|properties", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.util;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.zaxxer.hikari.HikariConfig;\n\n/**\n * A class that reflectively sets bean properties on a target object.\n *\n * @author Brett Wooldridge\n */\npublic final class PropertyElf\n{\n   private static final Logger LOGGER = LoggerFactory.getLogger(PropertyElf.class);\n\n   private static final Pattern GETTER_PATTERN = Pattern.compile(\"(get|is)[A-Z].+\");\n\n   public static void METHOD_NAME(final Object target, final Properties properties)\n   {\n      if (target == null || properties == null) {\n         return;\n      }\n\n      List<Method> methods = Arrays.asList(target.getClass().getMethods());\n      properties.forEach((key, value) -> {\n         if (target instanceof HikariConfig && key.toString().startsWith(\"dataSource.\")) {\n            ((HikariConfig) target).addDataSourceProperty(key.toString().substring(\"dataSource.\".length()), value);\n         }\n         else {\n            setProperty(target, key.toString(), value, methods);\n         }\n      });\n   }\n\n   /**\n    * Get the bean-style property names for the specified object.\n    *\n    * @param targetClass the target object\n    * @return a set of property names\n    */\n   public static Set<String> getPropertyNames(final Class<?> targetClass)\n   {\n      HashSet<String> set = new HashSet<>();\n      Matcher matcher = GETTER_PATTERN.matcher(\"\");\n      for (Method method : targetClass.getMethods()) {\n         String name = method.getName();\n         if (method.getParameterTypes().length == 0 && matcher.reset(name).matches()) {\n            name = name.replaceFirst(\"(get|is)\", \"\");\n            try {\n               if (targetClass.getMethod(\"set\" + name, method.getReturnType()) != null) {\n                  name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n                  set.add(name);\n               }\n            }\n            catch (Exception e) {\n               continue;\n            }\n         }\n      }\n\n      return set;\n   }\n\n   public static Object getProperty(final String propName, final Object target)\n   {\n      try {\n         // use the english locale to avoid the infamous turkish locale bug\n         String capitalized = \"get\" + propName.substring(0, 1).toUpperCase(Locale.ENGLISH) + propName.substring(1);\n         Method method = target.getClass().getMethod(capitalized);\n         return method.invoke(target);\n      }\n      catch (Exception e) {\n         try {\n            String capitalized = \"is\" + propName.substring(0, 1).toUpperCase(Locale.ENGLISH) + propName.substring(1);\n            Method method = target.getClass().getMethod(capitalized);\n            return method.invoke(target);\n         }\n         catch (Exception e2) {\n            return null;\n         }\n      }\n   }\n\n   public static Properties copyProperties(final Properties props)\n   {\n      Properties copy = new Properties();\n      props.forEach((key, value) -> copy.setProperty(key.toString(), value.toString()));\n      return copy;\n   }\n\n   private static void setProperty(final Object target, final String propName, final Object propValue, final List<Method> methods)\n   {\n      // use the english locale to avoid the infamous turkish locale bug\n      String methodName = \"set\" + propName.substring(0, 1).toUpperCase(Locale.ENGLISH) + propName.substring(1);\n      Method writeMethod = methods.stream().filter(m -> m.getName().equals(methodName) && m.getParameterCount() == 1).findFirst().orElse(null);\n\n      if (writeMethod == null) {\n         String methodName2 = \"set\" + propName.toUpperCase(Locale.ENGLISH);\n         writeMethod = methods.stream().filter(m -> m.getName().equals(methodName2) && m.getParameterCount() == 1).findFirst().orElse(null);\n      }\n\n      if (writeMethod == null) {\n         LOGGER.error(\"Property {} does not exist on target {}\", propName, target.getClass());\n         throw new RuntimeException(String.format(\"Property %s does not exist on target %s\", propName, target.getClass()));\n      }\n\n      try {\n         Class<?> paramClass = writeMethod.getParameterTypes()[0];\n         if (paramClass == int.class) {\n            writeMethod.invoke(target, Integer.parseInt(propValue.toString()));\n         }\n         else if (paramClass == long.class) {\n            writeMethod.invoke(target, Long.parseLong(propValue.toString()));\n         }\n         else if (paramClass == boolean.class || paramClass == Boolean.class) {\n            writeMethod.invoke(target, Boolean.parseBoolean(propValue.toString()));\n         }\n         else if (paramClass == String.class) {\n            writeMethod.invoke(target, propValue.toString());\n         }\n         else {\n            writeMethod.invoke(target, propValue);\n         }\n      }\n      catch (Exception e) {\n         LOGGER.error(\"Failed to set property {} on target {}\", propName, target.getClass(), e);\n         throw new RuntimeException(e);\n      }\n   }\n}\n"}
{"label": "load|configuration", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.hibernate;\n\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.hibernate.cfg.AvailableSettings;\n\nimport com.zaxxer.hikari.HikariConfig;\n\n/**\n * Utility class to map Hibernate properties to HikariCP configuration properties.\n *\n * @author Brett Wooldridge, Luca Burgazzoli\n */\npublic class HikariConfigurationUtil\n{\n   public static final String CONFIG_PREFIX = \"hibernate.hikari.\";\n   public static final String CONFIG_PREFIX_DATASOURCE = \"hibernate.hikari.dataSource.\";\n\n   /**\n    * Create/load a HikariConfig from Hibernate properties.\n    *\n    * @param props a map of Hibernate properties\n    * @return a HikariConfig\n    */\n   @SuppressWarnings(\"rawtypes\")\n   public static HikariConfig METHOD_NAME(Map props)\n   {\n      Properties hikariProps = new Properties();\n      copyProperty(AvailableSettings.ISOLATION, props, \"transactionIsolation\", hikariProps);\n      copyProperty(AvailableSettings.AUTOCOMMIT, props, \"autoCommit\", hikariProps);\n      copyProperty(AvailableSettings.DRIVER, props, \"driverClassName\", hikariProps);\n      copyProperty(AvailableSettings.URL, props, \"jdbcUrl\", hikariProps);\n      copyProperty(AvailableSettings.USER, props, \"username\", hikariProps);\n      copyProperty(AvailableSettings.PASS, props, \"password\", hikariProps);\n\n      for (Object keyo : props.keySet()) {\n         String key = (String) keyo;\n         if (key.startsWith(CONFIG_PREFIX)) {\n            hikariProps.setProperty(key.substring(CONFIG_PREFIX.length()), (String) props.get(key));\n         }\n      }\n\n      return new HikariConfig(hikariProps);\n   }\n\n   @SuppressWarnings(\"rawtypes\")\n   private static void copyProperty(String srcKey, Map src, String dstKey, Properties dst)\n   {\n      if (src.containsKey(srcKey)) {\n         dst.setProperty(dstKey, (String) src.get(srcKey));\n      }\n   }\n}"}
{"label": "get|total|connections", "code": "/*\n * Copyright (C) 2015 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.metrics;\n\nimport static com.zaxxer.hikari.util.ClockSource.currentTime;\nimport static com.zaxxer.hikari.util.ClockSource.plusMillis;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic abstract class PoolStats\n{\n   private final AtomicLong reloadAt;\n   private final long timeoutMs;\n\n   protected volatile int totalConnections;\n   protected volatile int idleConnections;\n   protected volatile int activeConnections;\n   protected volatile int pendingThreads;\n\n   public PoolStats(final long timeoutMs)\n   {\n      this.timeoutMs = timeoutMs;\n      this.reloadAt = new AtomicLong();\n   }\n   \n   public int METHOD_NAME()\n   {\n      if (shouldLoad()) {\n         update();\n      }\n\n      return totalConnections;\n   }\n\n   public int getIdleConnections()\n   {\n      if (shouldLoad()) {\n         update();\n      }\n\n      return idleConnections;\n   }\n\n   public int getActiveConnections()\n   {\n      if (shouldLoad()) {\n         update();\n      }\n\n      return activeConnections;\n   }\n\n   public int getPendingThreads()\n   {\n      if (shouldLoad()) {\n         update();\n      }\n\n      return pendingThreads;\n   }\n\n   protected abstract void update();\n\n   private boolean shouldLoad()\n   {\n      for (; ; ) {\n          final long now = currentTime();\n          final long reloadTime = reloadAt.get();\n          if (reloadTime > now) {\n              return false;\n          }\n          else if (reloadAt.compareAndSet(reloadTime, plusMillis(now, timeoutMs))) {\n              return true;\n          }\n      }\n  }\n}\n"}
{"label": "get|registry", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.metrics.dropwizard;\n\nimport com.codahale.metrics.MetricRegistry;\nimport com.zaxxer.hikari.metrics.IMetricsTracker;\nimport com.zaxxer.hikari.metrics.MetricsTrackerFactory;\nimport com.zaxxer.hikari.metrics.PoolStats;\n\npublic final class CodahaleMetricsTrackerFactory implements MetricsTrackerFactory\n{\n   private final MetricRegistry registry;\n\n   public CodahaleMetricsTrackerFactory(MetricRegistry registry)\n   {\n      this.registry = registry;\n   }\n\n   public MetricRegistry METHOD_NAME()\n   {\n      return registry;\n   }\n\n   @Override\n   public IMetricsTracker create(String poolName, PoolStats poolStats)\n   {\n      return new CodaHaleMetricsTracker(poolName, poolStats, registry);\n   }\n}\n"}
{"label": "register|health|checks", "code": "/*\n * Copyright (C) 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.metrics.dropwizard;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\nimport java.util.SortedMap;\nimport java.util.concurrent.TimeUnit;\n\nimport com.codahale.metrics.Metric;\nimport com.codahale.metrics.MetricFilter;\nimport com.codahale.metrics.MetricRegistry;\nimport com.codahale.metrics.Timer;\nimport com.codahale.metrics.health.HealthCheck;\nimport com.codahale.metrics.health.HealthCheckRegistry;\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.pool.HikariPool;\n\n/**\n * Provides Dropwizard HealthChecks.  Two health checks are provided:\n * <ul>\n *   <li>ConnectivityCheck</li>\n *   <li>Connection99Percent</li>\n * </ul>\n * The ConnectivityCheck will use the <code>connectionTimeout</code>, unless the health check property\n * <code>connectivityCheckTimeoutMs</code> is defined.  However, if either the <code>connectionTimeout</code>\n * or the <code>connectivityCheckTimeoutMs</code> is 0 (infinite), a timeout of 10 seconds will be used.\n * <p>\n * The Connection99Percent health check will only be registered if the health check property\n * <code>expected99thPercentileMs</code> is defined and greater than 0.\n *\n * @author Brett Wooldridge\n */\npublic final class CodahaleHealthChecker\n{\n   /**\n    * Register Dropwizard health checks.\n    *\n    * @param pool the pool to register health checks for\n    * @param hikariConfig the pool configuration\n    * @param registry the HealthCheckRegistry into which checks will be registered\n    */\n   public static void METHOD_NAME(final HikariPool pool, final HikariConfig hikariConfig, final HealthCheckRegistry registry)\n   {\n      final Properties healthCheckProperties = hikariConfig.getHealthCheckProperties();\n      final MetricRegistry metricRegistry = (MetricRegistry) hikariConfig.getMetricRegistry();\n\n      final long checkTimeoutMs = Long.parseLong(healthCheckProperties.getProperty(\"connectivityCheckTimeoutMs\", String.valueOf(hikariConfig.getConnectionTimeout())));\n      registry.register(MetricRegistry.name(hikariConfig.getPoolName(), \"pool\", \"ConnectivityCheck\"), new ConnectivityHealthCheck(pool, checkTimeoutMs));\n\n      final long expected99thPercentile = Long.parseLong(healthCheckProperties.getProperty(\"expected99thPercentileMs\", \"0\"));\n      if (metricRegistry != null && expected99thPercentile > 0) {\n         SortedMap<String,Timer> timers = metricRegistry.getTimers(new MetricFilter() {\n            @Override\n            public boolean matches(String name, Metric metric)\n            {\n               return name.equals(MetricRegistry.name(hikariConfig.getPoolName(), \"pool\", \"Wait\"));\n            }\n         });\n\n         if (!timers.isEmpty()) {\n            final Timer timer = timers.entrySet().iterator().next().getValue();\n            registry.register(MetricRegistry.name(hikariConfig.getPoolName(), \"pool\", \"Connection99Percent\"), new Connection99Percent(timer, expected99thPercentile));\n         }\n      }\n   }\n\n   private CodahaleHealthChecker()\n   {\n      // private constructor\n   }\n\n   private static class ConnectivityHealthCheck extends HealthCheck\n   {\n      private final HikariPool pool;\n      private final long checkTimeoutMs;\n\n      ConnectivityHealthCheck(final HikariPool pool, final long checkTimeoutMs)\n      {\n         this.pool = pool;\n         this.checkTimeoutMs = (checkTimeoutMs > 0 && checkTimeoutMs != Integer.MAX_VALUE ? checkTimeoutMs : TimeUnit.SECONDS.toMillis(10));\n      }\n\n      /** {@inheritDoc} */\n      @Override\n      protected Result check() throws Exception\n      {\n         try (Connection connection = pool.getConnection(checkTimeoutMs)) {\n            return Result.healthy();\n         }\n         catch (SQLException e) {\n            return Result.unhealthy(e);\n         }\n      }\n   }\n\n   private static class Connection99Percent extends HealthCheck\n   {\n      private final Timer waitTimer;\n      private final long expected99thPercentile;\n\n      Connection99Percent(final Timer waitTimer, final long expected99thPercentile)\n      {\n         this.waitTimer = waitTimer;\n         this.expected99thPercentile = expected99thPercentile;\n      }\n\n      /** {@inheritDoc} */\n      @Override\n      protected Result check() throws Exception\n      {\n         final long the99thPercentile = TimeUnit.NANOSECONDS.toMillis(Math.round(waitTimer.getSnapshot().get99thPercentile()));\n         return the99thPercentile <= expected99thPercentile ? Result.healthy() : Result.unhealthy(\"99th percentile connection wait time of %dms exceeds the threshold %dms\", the99thPercentile, expected99thPercentile);\n      }\n   }\n}\n"}
{"label": "add", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.metrics.prometheus;\n\nimport com.zaxxer.hikari.metrics.PoolStats;\nimport io.prometheus.client.Collector;\nimport io.prometheus.client.GaugeMetricFamily;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\n\nclass HikariCPCollector extends Collector {\n\n   private static final List<String> LABEL_NAMES = Collections.singletonList(\"pool\");\n\n   private final Map<String, PoolStats> poolStatsMap = new ConcurrentHashMap<>();\n\n   @Override\n   public List<MetricFamilySamples> collect() {\n      return Arrays.asList(\n         createGauge(\"hikaricp_active_connections\", \"Active connections\",\n            PoolStats::getActiveConnections),\n         createGauge(\"hikaricp_idle_connections\", \"Idle connections\",\n            PoolStats::getIdleConnections),\n         createGauge(\"hikaricp_pending_threads\", \"Pending threads\",\n            PoolStats::getPendingThreads),\n         createGauge(\"hikaricp_connections\", \"The number of current connections\",\n            PoolStats::getTotalConnections)\n      );\n   }\n\n   protected HikariCPCollector METHOD_NAME(String name, PoolStats poolStats) {\n      poolStatsMap.put(name, poolStats);\n      return this;\n   }\n\n   private GaugeMetricFamily createGauge(String metric, String help,\n      Function<PoolStats, Integer> metricValueFunction) {\n      GaugeMetricFamily metricFamily = new GaugeMetricFamily(metric, help, LABEL_NAMES);\n      poolStatsMap.forEach((k, v) -> metricFamily.addMetric(\n         Collections.singletonList(k),\n         metricValueFunction.apply(v)\n      ));\n      return metricFamily;\n   }\n}\n"}
{"label": "get|collector", "code": "/*\n * Copyright (C) 2016 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.metrics.prometheus;\n\nimport com.zaxxer.hikari.metrics.IMetricsTracker;\nimport com.zaxxer.hikari.metrics.MetricsTrackerFactory;\nimport com.zaxxer.hikari.metrics.PoolStats;\n\n/**\n * <pre>{@code\n * HikariConfig config = new HikariConfig();\n * config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n * }</pre>\n */\npublic class PrometheusMetricsTrackerFactory implements MetricsTrackerFactory {\n\n   private static HikariCPCollector collector;\n\n   @Override\n   public IMetricsTracker create(String poolName, PoolStats poolStats) {\n      METHOD_NAME().add(poolName, poolStats);\n      return new PrometheusMetricsTracker(poolName);\n   }\n\n   /**\n    * initialize and register collector if it isn't initialized yet\n    */\n   private HikariCPCollector METHOD_NAME() {\n      if (collector == null) {\n         collector = new HikariCPCollector().register();\n      }\n      return collector;\n   }\n}\n"}
{"label": "check|exception", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n/**\n * This is the proxy class for java.sql.ResultSet.\n *\n * @author Brett Wooldridge\n */\npublic abstract class ProxyResultSet implements ResultSet\n{\n   protected final ProxyConnection connection;\n   protected final ProxyStatement statement;\n   final ResultSet delegate;\n\n   protected ProxyResultSet(ProxyConnection connection, ProxyStatement statement, ResultSet resultSet)\n   {\n      this.connection = connection;\n      this.statement = statement;\n      this.delegate = resultSet;\n   }\n\n   @SuppressWarnings(\"unused\")\n   final SQLException METHOD_NAME(SQLException e)\n   {\n      return connection.METHOD_NAME(e);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public String toString()\n   {\n      return this.getClass().getSimpleName() + '@' + System.identityHashCode(this) + \" wrapping \" + delegate;\n   }\n\n   // **********************************************************************\n   //                 Overridden java.sql.ResultSet Methods\n   // **********************************************************************\n\n   /** {@inheritDoc} */\n   @Override\n   public final Statement getStatement() throws SQLException\n   {\n      return statement;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void updateRow() throws SQLException\n   {\n      connection.markCommitStateDirty();\n      delegate.updateRow();\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void insertRow() throws SQLException\n   {\n      connection.markCommitStateDirty();\n      delegate.insertRow();\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void deleteRow() throws SQLException\n   {\n      connection.markCommitStateDirty();\n      delegate.deleteRow();\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   @SuppressWarnings(\"unchecked\")\n   public final <T> T unwrap(Class<T> iface) throws SQLException\n   {\n      if (iface.isInstance(delegate)) {\n         return (T) delegate;\n      }\n      else if (delegate != null) {\n          return delegate.unwrap(iface);\n      }\n\n      throw new SQLException(\"Wrapped ResultSet is not an instance of \" + iface);\n   }\n}\n"}
{"label": "check|exception", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n/**\n * This is the proxy class for java.sql.Statement.\n *\n * @author Brett Wooldridge\n */\npublic abstract class ProxyStatement implements Statement\n{\n   protected final ProxyConnection connection;\n   final Statement delegate;\n\n   private boolean isClosed;\n   private ResultSet proxyResultSet;\n\n   ProxyStatement(ProxyConnection connection, Statement statement)\n   {\n      this.connection = connection;\n      this.delegate = statement;\n   }\n\n   @SuppressWarnings(\"unused\")\n   final SQLException METHOD_NAME(SQLException e)\n   {\n      return connection.METHOD_NAME(e);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public final String toString()\n   {\n      final String delegateToString = delegate.toString();\n      return this.getClass().getSimpleName() + '@' + System.identityHashCode(this) + \" wrapping \" + delegateToString;\n   }\n\n   // **********************************************************************\n   //                 Overridden java.sql.Statement Methods\n   // **********************************************************************\n\n   /** {@inheritDoc} */\n   @Override\n   public final void close() throws SQLException\n   {\n      synchronized (this) {\n         if (isClosed) {\n            return;\n         }\n\n         isClosed = true;\n      }\n\n      connection.untrackStatement(delegate);\n\n      try {\n         delegate.close();\n      }\n      catch (SQLException e) {\n         throw connection.METHOD_NAME(e);\n      }\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public Connection getConnection() throws SQLException\n   {\n      return connection;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public boolean execute(String sql) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.execute(sql);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.execute(sql, autoGeneratedKeys);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public ResultSet executeQuery(String sql) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      ResultSet resultSet = delegate.executeQuery(sql);\n      return ProxyFactory.getProxyResultSet(connection, this, resultSet);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public int executeUpdate(String sql) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeUpdate(sql);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public int[] executeBatch() throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeBatch();\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeUpdate(sql, autoGeneratedKeys);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeUpdate(sql, columnIndexes);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public int executeUpdate(String sql, String[] columnNames) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeUpdate(sql, columnNames);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public boolean execute(String sql, int[] columnIndexes) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.execute(sql, columnIndexes);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public boolean execute(String sql, String[] columnNames) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.execute(sql, columnNames);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public long[] executeLargeBatch() throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeLargeBatch();\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public long executeLargeUpdate(String sql) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeLargeUpdate(sql);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeLargeUpdate(sql, autoGeneratedKeys);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeLargeUpdate(sql, columnIndexes);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException\n   {\n      connection.markCommitStateDirty();\n      return delegate.executeLargeUpdate(sql, columnNames);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public ResultSet getResultSet() throws SQLException {\n      final ResultSet resultSet = delegate.getResultSet();\n      if (resultSet != null) {\n         if (proxyResultSet == null || ((ProxyResultSet) proxyResultSet).delegate != resultSet) {\n            proxyResultSet = ProxyFactory.getProxyResultSet(connection, this, resultSet);\n         }\n      }\n      else {\n         proxyResultSet = null;\n      }\n      return proxyResultSet;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   @SuppressWarnings(\"unchecked\")\n   public final <T> T unwrap(Class<T> iface) throws SQLException\n   {\n      if (iface.isInstance(delegate)) {\n         return (T) delegate;\n      }\n      else if (delegate != null) {\n          return delegate.unwrap(iface);\n      }\n\n      throw new SQLException(\"Wrapped statement is not an instance of \" + iface);\n   }\n}\n"}
{"label": "get|proxy|connection", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\nimport com.zaxxer.hikari.util.FastList;\n\n/**\n * A factory class that produces proxies around instances of the standard\n * JDBC interfaces.\n *\n * @author Brett Wooldridge\n */\n@SuppressWarnings(\"unused\")\npublic final class ProxyFactory\n{\n   private ProxyFactory()\n   {\n      // unconstructable\n   }\n\n   /**\n    * Create a proxy for the specified {@link Connection} instance.\n    * @param poolEntry the PoolEntry holding pool state\n    * @param connection the raw database Connection\n    * @param openStatements a reusable list to track open Statement instances\n    * @param leakTask the ProxyLeakTask for this connection\n    * @param now the current timestamp\n    * @param isReadOnly the default readOnly state of the connection\n    * @param isAutoCommit the default autoCommit state of the connection\n    * @return a proxy that wraps the specified {@link Connection}\n    */\n   static ProxyConnection METHOD_NAME(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }\n\n   static Statement getProxyStatement(final ProxyConnection connection, final Statement statement)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }\n\n   static CallableStatement getProxyCallableStatement(final ProxyConnection connection, final CallableStatement statement)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }\n\n   static PreparedStatement getProxyPreparedStatement(final ProxyConnection connection, final PreparedStatement statement)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }\n\n   static ResultSet getProxyResultSet(final ProxyConnection connection, final ProxyStatement statement, final ResultSet resultSet)\n   {\n      // Body is replaced (injected) by JavassistProxyFactory\n      throw new IllegalStateException(\"You need to run the CLI build and you need target/classes in your classpath to run.\");\n   }\n}\n"}
{"label": "schedule", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport java.util.concurrent.ScheduledExecutorService;\n\n/**\n * A factory for {@link ProxyLeakTask} Runnables that are scheduled in the future to report leaks.\n *\n * @author Brett Wooldridge\n * @author Andreas Brenk\n */\nclass ProxyLeakTaskFactory\n{\n   private ScheduledExecutorService executorService;\n   private long leakDetectionThreshold;\n\n   ProxyLeakTaskFactory(final long leakDetectionThreshold, final ScheduledExecutorService executorService)\n   {\n      this.executorService = executorService;\n      this.leakDetectionThreshold = leakDetectionThreshold;\n   }\n\n   ProxyLeakTask METHOD_NAME(final PoolEntry poolEntry)\n   {\n      return (leakDetectionThreshold == 0) ? ProxyLeakTask.NO_LEAK : scheduleNewTask(poolEntry);\n   }\n\n   void updateLeakDetectionThreshold(final long leakDetectionThreshold)\n   {\n      this.leakDetectionThreshold = leakDetectionThreshold;\n   }\n\n   private ProxyLeakTask scheduleNewTask(PoolEntry poolEntry) {\n      ProxyLeakTask task = new ProxyLeakTask(poolEntry);\n      task.METHOD_NAME(executorService, leakDetectionThreshold);\n\n      return task;\n   }\n}\n"}
{"label": "recycle", "code": "/*\n * Copyright (C) 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.zaxxer.hikari.pool;\n\nimport com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry;\nimport com.zaxxer.hikari.util.FastList;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n\nimport static com.zaxxer.hikari.util.ClockSource.*;\n\n/**\n * Entry used in the ConcurrentBag to track Connection instances.\n *\n * @author Brett Wooldridge\n */\nfinal class PoolEntry implements IConcurrentBagEntry\n{\n   private static final Logger LOGGER = LoggerFactory.getLogger(PoolEntry.class);\n   private static final AtomicIntegerFieldUpdater<PoolEntry> stateUpdater;\n\n   Connection connection;\n   long lastAccessed;\n   long lastBorrowed;\n\n   @SuppressWarnings(\"FieldCanBeLocal\")\n   private volatile int state = 0;\n   private volatile boolean evict;\n\n   private volatile ScheduledFuture<?> endOfLife;\n\n   private final FastList<Statement> openStatements;\n   private final HikariPool hikariPool;\n\n   private final boolean isReadOnly;\n   private final boolean isAutoCommit;\n\n   static\n   {\n      stateUpdater = AtomicIntegerFieldUpdater.newUpdater(PoolEntry.class, \"state\");\n   }\n\n   PoolEntry(final Connection connection, final PoolBase pool, final boolean isReadOnly, final boolean isAutoCommit)\n   {\n      this.connection = connection;\n      this.hikariPool = (HikariPool) pool;\n      this.isReadOnly = isReadOnly;\n      this.isAutoCommit = isAutoCommit;\n      this.lastAccessed = currentTime();\n      this.openStatements = new FastList<>(Statement.class, 16);\n   }\n\n   /**\n    * Release this entry back to the pool.\n    *\n    * @param lastAccessed last access time-stamp\n    */\n   void METHOD_NAME(final long lastAccessed)\n   {\n      if (connection != null) {\n         this.lastAccessed = lastAccessed;\n         hikariPool.METHOD_NAME(this);\n      }\n   }\n\n   /**\n    * Set the end of life {@link ScheduledFuture}.\n    *\n    * @param endOfLife this PoolEntry/Connection's end of life {@link ScheduledFuture}\n    */\n   void setFutureEol(final ScheduledFuture<?> endOfLife)\n   {\n      this.endOfLife = endOfLife;\n   }\n\n   Connection createProxyConnection(final ProxyLeakTask leakTask, final long now)\n   {\n      return ProxyFactory.getProxyConnection(this, connection, openStatements, leakTask, now, isReadOnly, isAutoCommit);\n   }\n\n   void resetConnectionState(final ProxyConnection proxyConnection, final int dirtyBits) throws SQLException\n   {\n      hikariPool.resetConnectionState(connection, proxyConnection, dirtyBits);\n   }\n\n   String getPoolName()\n   {\n      return hikariPool.toString();\n   }\n\n   boolean isMarkedEvicted()\n   {\n      return evict;\n   }\n\n   void markEvicted()\n   {\n      this.evict = true;\n   }\n\n   void evict(final String closureReason)\n   {\n      hikariPool.closeConnection(this, closureReason);\n   }\n\n   /** Returns millis since lastBorrowed */\n   long getMillisSinceBorrowed()\n   {\n      return elapsedMillis(lastBorrowed);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public String toString()\n   {\n      final long now = currentTime();\n      return connection\n         + \", accessed \" + elapsedDisplayString(lastAccessed, now) + \" ago, \"\n         + stateToString();\n   }\n\n   // ***********************************************************************\n   //                      IConcurrentBagEntry methods\n   // ***********************************************************************\n\n   /** {@inheritDoc} */\n   @Override\n   public int getState()\n   {\n      return stateUpdater.get(this);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public boolean compareAndSet(int expect, int update)\n   {\n      return stateUpdater.compareAndSet(this, expect, update);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void setState(int update)\n   {\n      stateUpdater.set(this, update);\n   }\n\n   Connection close()\n   {\n      ScheduledFuture<?> eol = endOfLife;\n      if (eol != null && !eol.isDone() && !eol.cancel(false)) {\n         LOGGER.warn(\"{} - maxLifeTime expiration task cancellation unexpectedly returned false for connection {}\", getPoolName(), connection);\n      }\n\n      Connection con = connection;\n      connection = null;\n      endOfLife = null;\n      return con;\n   }\n\n   private String stateToString()\n   {\n      switch (state) {\n      case STATE_IN_USE:\n         return \"IN_USE\";\n      case STATE_NOT_IN_USE:\n         return \"NOT_IN_USE\";\n      case STATE_REMOVED:\n         return \"REMOVED\";\n      case STATE_RESERVED:\n         return \"RESERVED\";\n      default:\n         return \"Invalid\";\n      }\n   }\n}\n"}
{"label": "schedule", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A Runnable that is scheduled in the future to report leaks.  The ScheduledFuture is\n * cancelled if the connection is closed before the leak time expires.\n *\n * @author Brett Wooldridge\n */\nclass ProxyLeakTask implements Runnable\n{\n   private static final Logger LOGGER = LoggerFactory.getLogger(ProxyLeakTask.class);\n   static final ProxyLeakTask NO_LEAK;\n\n   private ScheduledFuture<?> scheduledFuture;\n   private String connectionName;\n   private Exception exception;\n   private String threadName; \n   private boolean isLeaked;\n\n   static\n   {\n      NO_LEAK = new ProxyLeakTask() {\n         @Override\n         void METHOD_NAME(ScheduledExecutorService executorService, long leakDetectionThreshold) {}\n\n         @Override\n         public void run() {}\n\n         @Override\n         public void cancel() {}\n      };\n   }\n\n   ProxyLeakTask(final PoolEntry poolEntry)\n   {\n      this.exception = new Exception(\"Apparent connection leak detected\");\n      this.threadName = Thread.currentThread().getName();\n      this.connectionName = poolEntry.connection.toString();\n   }\n\n   private ProxyLeakTask()\n   {\n   }\n\n   void METHOD_NAME(ScheduledExecutorService executorService, long leakDetectionThreshold)\n   {\n      scheduledFuture = executorService.METHOD_NAME(this, leakDetectionThreshold, TimeUnit.MILLISECONDS);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void run()\n   {\n      isLeaked = true;\n\n      final StackTraceElement[] stackTrace = exception.getStackTrace(); \n      final StackTraceElement[] trace = new StackTraceElement[stackTrace.length - 5];\n      System.arraycopy(stackTrace, 5, trace, 0, trace.length);\n\n      exception.setStackTrace(trace);\n      LOGGER.warn(\"Connection leak detection triggered for {} on thread {}, stack trace follows\", connectionName, threadName, exception);\n   }\n\n   void cancel()\n   {\n      scheduledFuture.cancel(false);\n      if (isLeaked) {\n         LOGGER.info(\"Previously reported leaked connection {} on thread {} was returned to the pool (unleaked)\", connectionName, threadName);\n      }\n   }\n}\n"}
{"label": "create|data|source", "code": "/*\n * Copyright (C) 2013,2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.Name;\nimport javax.naming.NamingException;\nimport javax.naming.RefAddr;\nimport javax.naming.Reference;\nimport javax.naming.spi.ObjectFactory;\nimport javax.sql.DataSource;\n\nimport com.zaxxer.hikari.util.PropertyElf;\n\n/**\n * A JNDI factory that produces HikariDataSource instances.\n *\n * @author Brett Wooldridge\n */\npublic class HikariJNDIFactory implements ObjectFactory\n{\n   @Override\n   synchronized public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception\n   {\n      // We only know how to deal with <code>javax.naming.Reference</code> that specify a class name of \"javax.sql.DataSource\"\n      if (obj instanceof Reference && \"javax.sql.DataSource\".equals(((Reference) obj).getClassName())) {\n         Reference ref = (Reference) obj;\n         Set<String> hikariPropSet = PropertyElf.getPropertyNames(HikariConfig.class);\n\n         Properties properties = new Properties();\n         Enumeration<RefAddr> enumeration = ref.getAll();\n         while (enumeration.hasMoreElements()) {\n            RefAddr element = enumeration.nextElement();\n            String type = element.getType();\n            if (type.startsWith(\"dataSource.\") || hikariPropSet.contains(type)) {\n               properties.setProperty(type, element.getContent().toString());\n            }\n         }\n         return METHOD_NAME(properties, nameCtx);\n      }\n      return null;\n   }\n\n   private DataSource METHOD_NAME(final Properties properties, final Context context) throws NamingException\n   {\n      String jndiName = properties.getProperty(\"dataSourceJNDI\");\n      if (jndiName != null) {\n         return lookupJndiDataSource(properties, context, jndiName);\n      }\n\n      return new HikariDataSource(new HikariConfig(properties));\n   }\n\n   private DataSource lookupJndiDataSource(final Properties properties, final Context context, final String jndiName) throws NamingException\n   {\n      if (context == null) {\n         throw new RuntimeException(\"JNDI context does not found for dataSourceJNDI : \" + jndiName);\n      }\n\n      DataSource jndiDS = (DataSource) context.lookup(jndiName);\n      if (jndiDS == null) {\n         final Context ic = new InitialContext();\n         jndiDS = (DataSource) ic.lookup(jndiName);\n         ic.close();\n      }\n\n      if (jndiDS != null) {\n         HikariConfig config = new HikariConfig(properties);\n         config.setDataSource(jndiDS);\n         return new HikariDataSource(config);\n      }\n\n      return null;\n   }\n}\n"}
{"label": "test|add|remove", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertSame;\n\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.mocks.StubStatement;\n\npublic class TestFastList\n{\n    @Test\n    public void METHOD_NAME()\n    {\n        ArrayList<Statement> verifyList = new ArrayList<>();\n\n        FastList<Statement> list = new FastList<>(Statement.class);\n        for (int i = 0; i < 32; i++)\n        {\n            StubStatement statement = new StubStatement(null);\n            list.add(statement);\n            verifyList.add(statement);\n        }\n\n        for (int i = 0; i < 32; i++)\n        {\n            assertNotNull(\"Element \" + i + \" was null but should be \" + verifyList.get(i), list.get(0));\n            int size = list.size();\n            list.remove(verifyList.get(i));\n            assertSame(size - 1, list.size());\n        }\n    }\n\n    @Test\n    public void testAddRemoveTail()\n    {\n        ArrayList<Statement> verifyList = new ArrayList<>();\n\n        FastList<Statement> list = new FastList<>(Statement.class);\n        for (int i = 0; i < 32; i++)\n        {\n            StubStatement statement = new StubStatement(null);\n            list.add(statement);\n            verifyList.add(statement);\n        }\n\n        for (int i = 31; i >= 0; i--)\n        {\n            assertNotNull(\"Element \" + i, list.get(i));\n            int size = list.size();\n            list.remove(verifyList.get(i));\n            assertSame(size - 1, list.size());\n        }\n    }\n\n    @Test\n    public void testOverflow()\n    {\n        ArrayList<Statement> verifyList = new ArrayList<>();\n\n        FastList<Statement> list = new FastList<>(Statement.class);\n        for (int i = 0; i < 100; i++)\n        {\n            StubStatement statement = new StubStatement(null);\n            list.add(statement);\n            verifyList.add(statement);\n        }\n\n        for (int i = 0; i < 100; i++)\n        {\n            assertNotNull(\"Element \" + i, list.get(i));\n            assertSame(verifyList.get(i), list.get(i));\n        }\n    }\n\n    @Test\n    public void testIterator()\n    {\n       FastList<Statement> list = new FastList<>(Statement.class);\n       for (int i = 0; i < 100; i++)\n       {\n           StubStatement statement = new StubStatement(null);\n           list.add(statement);\n       }\n\n       Iterator<Statement> iter = list.iterator();\n       for (int i = 0;  i < list.size(); i++) {\n          assertSame(list.get(i), iter.next());\n       }\n    }\n\n    @Test\n    public void testClear()\n    {\n       FastList<Statement> list = new FastList<>(Statement.class);\n       for (int i = 0; i < 100; i++)\n       {\n           StubStatement statement = new StubStatement(null);\n           list.add(statement);\n       }\n\n       assertNotEquals(0, list.size());\n       list.clear();\n       assertEquals(0, list.size());\n       // also check that all elements are now null\n       for (int i = 0; i < 100; i++) {\n           assertEquals(null, list.get(i));\n       }\n    }\n\n    @Test\n    public void testRemoveLast()\n    {\n       FastList<Statement> list = new FastList<>(Statement.class);\n\n       Statement last = null;\n       for (int i = 0; i < 100; i++)\n       {\n           StubStatement statement = new StubStatement(null);\n           list.add(statement);\n           last = statement;\n       }\n\n       assertEquals(last, list.removeLast());\n       assertEquals(99, list.size());\n    }\n\n    @Test\n    public void testPolyMorphism1()\n    {\n       class Foo implements Base2 {\n\n       }\n\n       class Bar extends Foo {\n\n       }\n\n       FastList<Base> list = new FastList<>(Base.class, 2);\n       list.add(new Foo());\n       list.add(new Foo());\n       list.add(new Bar());\n    }\n\n    interface Base\n    {\n\n    }\n\n    interface Base2 extends Base\n    {\n\n    }\n}\n"}
{"label": "test|clock|source|display", "code": "/*\n * Copyright (C) 2016 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.util;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static java.util.concurrent.TimeUnit.DAYS;\nimport static java.util.concurrent.TimeUnit.HOURS;\nimport static java.util.concurrent.TimeUnit.MICROSECONDS;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.MINUTES;\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\nimport static java.util.concurrent.TimeUnit.SECONDS;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic class ClockSourceTest\n{\n   @Test\n   public void METHOD_NAME()\n   {\n      ClockSource msSource = new ClockSource.MillisecondClockSource();\n\n      final long sTime = DAYS.toMillis(3) + HOURS.toMillis(9) + MINUTES.toMillis(24) + SECONDS.toMillis(18) + MILLISECONDS.toMillis(572);\n\n      final long eTime = DAYS.toMillis(4) + HOURS.toMillis(9) + MINUTES.toMillis(55) + SECONDS.toMillis(23) + MILLISECONDS.toMillis(777);\n      String ds1 = msSource.elapsedDisplayString0(sTime, eTime);\n      Assert.assertEquals(\"1d31m5s205ms\", ds1);\n\n      final long eTime2 = DAYS.toMillis(3) + HOURS.toMillis(8) + MINUTES.toMillis(24) + SECONDS.toMillis(23) + MILLISECONDS.toMillis(777);\n      String ds2 = msSource.elapsedDisplayString0(sTime, eTime2);\n      Assert.assertEquals(\"-59m54s795ms\", ds2);\n\n      \n      ClockSource nsSource = new ClockSource.NanosecondClockSource();\n\n      final long sTime2 = DAYS.toNanos(3) + HOURS.toNanos(9) + MINUTES.toNanos(24) + SECONDS.toNanos(18) + MILLISECONDS.toNanos(572) + MICROSECONDS.toNanos(324) + NANOSECONDS.toNanos(823);\n\n      final long eTime3 = DAYS.toNanos(4) + HOURS.toNanos(19) + MINUTES.toNanos(55) + SECONDS.toNanos(23) + MILLISECONDS.toNanos(777) + MICROSECONDS.toNanos(0) + NANOSECONDS.toNanos(982);\n      String ds3 = nsSource.elapsedDisplayString0(sTime2, eTime3);\n      Assert.assertEquals(\"1d10h31m5s204ms676\u00b5s159ns\", ds3);\n   }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (C) 2016 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.db;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.pool.HikariPool;\n\n/**\n * @author brettw\n *\n */\npublic class BasicPoolTest\n{\n   @Before\n   public void METHOD_NAME() throws SQLException\n   {\n       HikariConfig config = newHikariConfig();\n       config.setMinimumIdle(1);\n       config.setMaximumPoolSize(2);\n       config.setConnectionTestQuery(\"SELECT 1\");\n       config.setDataSourceClassName(\"org.h2.jdbcx.JdbcDataSource\");\n       config.addDataSourceProperty(\"url\", \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n       try (HikariDataSource ds = new HikariDataSource(config);\n            Connection conn = ds.getConnection();\n            Statement stmt = conn.createStatement()) {\n          stmt.executeUpdate(\"DROP TABLE IF EXISTS basic_pool_test\");\n          stmt.executeUpdate(\"CREATE TABLE basic_pool_test (\"\n                            + \"id INTEGER NOT NULL IDENTITY PRIMARY KEY, \"\n                            + \"timestamp TIMESTAMP, \"\n                            + \"string VARCHAR(128), \"\n                            + \"string_from_number NUMERIC \"\n                            + \")\");\n       }\n   }\n\n   @Test\n   public void testIdleTimeout() throws InterruptedException, SQLException\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(5);\n      config.setMaximumPoolSize(10);\n      config.setConnectionTestQuery(\"SELECT 1\");\n      config.setDataSourceClassName(\"org.h2.jdbcx.JdbcDataSource\");\n      config.addDataSourceProperty(\"url\", \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n      System.setProperty(\"com.zaxxer.hikari.housekeeping.periodMs\", \"1000\");\n\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         System.clearProperty(\"com.zaxxer.hikari.housekeeping.periodMs\");\n\n         SECONDS.sleep(1);\n\n         HikariPool pool = getPool(ds);\n\n         ds.setIdleTimeout(3000);\n\n         assertEquals(\"Total connections not as expected\", 5, pool.getTotalConnections());\n         assertEquals(\"Idle connections not as expected\", 5, pool.getIdleConnections());\n\n         try (Connection connection = ds.getConnection()) {\n            Assert.assertNotNull(connection);\n   \n            MILLISECONDS.sleep(1500);\n   \n            assertEquals(\"Second total connections not as expected\", 6, pool.getTotalConnections());\n            assertEquals(\"Second idle connections not as expected\", 5, pool.getIdleConnections());\n         }\n\n         assertEquals(\"Idle connections not as expected\", 6, pool.getIdleConnections());\n\n         SECONDS.sleep(2);\n\n         assertEquals(\"Third total connections not as expected\", 5, pool.getTotalConnections());\n         assertEquals(\"Third idle connections not as expected\", 5, pool.getIdleConnections());\n      }\n   }\n\n   @Test\n   public void testIdleTimeout2() throws InterruptedException, SQLException\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMaximumPoolSize(50);\n      config.setConnectionTestQuery(\"SELECT 1\");\n      config.setDataSourceClassName(\"org.h2.jdbcx.JdbcDataSource\");\n      config.addDataSourceProperty(\"url\", \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n      System.setProperty(\"com.zaxxer.hikari.housekeeping.periodMs\", \"1000\");\n\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         System.clearProperty(\"com.zaxxer.hikari.housekeeping.periodMs\");\n\n         SECONDS.sleep(1);\n\n         HikariPool pool = getPool(ds);\n\n         ds.setIdleTimeout(3000);\n\n         assertEquals(\"Total connections not as expected\", 50, pool.getTotalConnections());\n         assertEquals(\"Idle connections not as expected\", 50, pool.getIdleConnections());\n\n         try (Connection connection = ds.getConnection()) {\n            assertNotNull(connection);\n   \n            MILLISECONDS.sleep(1500);\n   \n            assertEquals(\"Second total connections not as expected\", 50, pool.getTotalConnections());\n            assertEquals(\"Second idle connections not as expected\", 49, pool.getIdleConnections());\n         }\n\n         assertEquals(\"Idle connections not as expected\", 50, pool.getIdleConnections());\n\n         SECONDS.sleep(3);\n\n         assertEquals(\"Third total connections not as expected\", 50, pool.getTotalConnections());\n         assertEquals(\"Third idle connections not as expected\", 50, pool.getIdleConnections());\n      }\n   }\n}\n"}
{"label": "setup", "code": "package com.zaxxer.hikari.metrics.dropwizard;\n\nimport static org.mockito.Mockito.verify;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport com.codahale.metrics.MetricRegistry;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class CodaHaleMetricsTrackerTest {\n\n   @Mock\n   public MetricRegistry mockMetricRegistry;\n\n   private CodaHaleMetricsTracker testee;\n\n   @Before\n   public void METHOD_NAME(){\n      testee = new CodaHaleMetricsTracker(\"mypool\", null, mockMetricRegistry);\n   }\n\n   @Test\n   public void close() throws Exception {\n      testee.close();\n\n      verify(mockMetricRegistry).remove(\"mypool.pool.Wait\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.Usage\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.ConnectionCreation\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.ConnectionTimeoutRate\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.TotalConnections\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.IdleConnections\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.ActiveConnections\");\n      verify(mockMetricRegistry).remove(\"mypool.pool.PendingConnections\");\n   }\n}\n"}
{"label": "setup", "code": "package com.zaxxer.hikari.metrics.micrometer;\n\nimport com.zaxxer.hikari.metrics.PoolStats;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport io.micrometer.core.instrument.simple.SimpleMeterRegistry;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class MicrometerMetricsTrackerTest {\n\n   private MeterRegistry mockMeterRegistry = new SimpleMeterRegistry();\n\n   private MicrometerMetricsTracker testee;\n\n   @Before\n   public void METHOD_NAME(){\n      testee = new MicrometerMetricsTracker(\"mypool\", new PoolStats(1000L) {\n         @Override\n         protected void update() {\n            // nothing\n         }\n      }, mockMeterRegistry);\n   }\n\n   @Test\n   public void close() throws Exception {\n      Assert.assertNotNull(mockMeterRegistry.find(\"Wait\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"Usage\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"ConnectionCreation\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"ConnectionTimeoutRate\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"TotalConnections\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"IdleConnections\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"ActiveConnections\"));\n      Assert.assertNotNull(mockMeterRegistry.find(\"PendingConnections\"));\n\n      testee.close();\n   }\n}\n"}
{"label": "record|connection|timeout", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.metrics.prometheus;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\nimport java.sql.Connection;\nimport java.sql.SQLTransientConnectionException;\n\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport io.prometheus.client.CollectorRegistry;\n\npublic class PrometheusMetricsTrackerTest {\n\n   @Test\n   public void METHOD_NAME() throws Exception {\n      HikariConfig config = newHikariConfig();\n      config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n      config.setJdbcUrl(\"jdbc:h2:mem:\");\n      config.setMaximumPoolSize(2);\n      config.setConnectionTimeout(250);\n\n      String[] labelNames = {\"pool\"};\n      String[] labelValues = {config.getPoolName()};\n\n      try (HikariDataSource hikariDataSource = new HikariDataSource(config)) {\n         try (Connection connection1 = hikariDataSource.getConnection();\n            Connection connection2 = hikariDataSource.getConnection()) {\n            try (Connection connection3 = hikariDataSource.getConnection()) {\n            }\n            catch (SQLTransientConnectionException ignored) {\n            }\n         }\n\n         assertThat(CollectorRegistry.defaultRegistry.getSampleValue(\n            \"hikaricp_connection_timeout_total\",\n            labelNames,\n            labelValues), is(1.0));\n         assertThat(CollectorRegistry.defaultRegistry.getSampleValue(\n            \"hikaricp_connection_acquired_nanos_count\",\n            labelNames,\n            labelValues), is(equalTo(3.0)));\n         assertTrue(CollectorRegistry.defaultRegistry.getSampleValue(\n            \"hikaricp_connection_acquired_nanos_sum\",\n            labelNames,\n            labelValues) > 0.0);\n         assertThat(CollectorRegistry.defaultRegistry.getSampleValue(\n            \"hikaricp_connection_usage_millis_count\",\n            labelNames,\n            labelValues), is(equalTo(2.0)));\n         assertTrue(CollectorRegistry.defaultRegistry.getSampleValue(\n            \"hikaricp_connection_usage_millis_sum\",\n            labelNames,\n            labelValues) > 0.0);\n      }\n   }\n\n   @Test\n   public void testMultiplePoolName() throws Exception {\n      String[] labelNames = {\"pool\"};\n\n      HikariConfig config = newHikariConfig();\n      config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n      config.setPoolName(\"first\");\n      config.setJdbcUrl(\"jdbc:h2:mem:\");\n      config.setMaximumPoolSize(2);\n      config.setConnectionTimeout(250);\n      String[] labelValues1 = {config.getPoolName()};\n\n      try (HikariDataSource ignored = new HikariDataSource(config)) {\n         assertThat(CollectorRegistry.defaultRegistry.getSampleValue(\n            \"hikaricp_connection_timeout_total\",\n            labelNames,\n            labelValues1), is(0.0));\n\n         HikariConfig config2 = newHikariConfig();\n         config2.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n         config2.setPoolName(\"second\");\n         config2.setJdbcUrl(\"jdbc:h2:mem:\");\n         config2.setMaximumPoolSize(4);\n         config2.setConnectionTimeout(250);\n         String[] labelValues2 = {config2.getPoolName()};\n\n         try (HikariDataSource ignored2 = new HikariDataSource(config2)) {\n            assertThat(CollectorRegistry.defaultRegistry.getSampleValue(\n               \"hikaricp_connection_timeout_total\",\n               labelNames,\n               labelValues2), is(0.0));\n         }\n      }\n   }\n}\n"}
{"label": "no|connection", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.metrics.prometheus;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.util.UtilityElf.quietlySleep;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\n\nimport java.sql.Connection;\n\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.mocks.StubConnection;\n\nimport io.prometheus.client.CollectorRegistry;\n\npublic class HikariCPCollectorTest {\n   @Test\n   public void METHOD_NAME() throws Exception {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(0);\n      config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      StubConnection.slowCreate = true;\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         assertThat(getValue(\"hikaricp_active_connections\", \"noConnection\"), is(0.0));\n         assertThat(getValue(\"hikaricp_idle_connections\", \"noConnection\"), is(0.0));\n         assertThat(getValue(\"hikaricp_pending_threads\", \"noConnection\"), is(0.0));\n         assertThat(getValue(\"hikaricp_connections\", \"noConnection\"), is(0.0));\n      }\n      finally {\n         StubConnection.slowCreate = false;\n      }\n   }\n\n   @Test\n   public void noConnectionWithoutPoolName() throws Exception {\n      HikariConfig config = new HikariConfig();\n      config.setMinimumIdle(0);\n      config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      StubConnection.slowCreate = true;\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         String poolName = ds.getHikariConfigMXBean().getPoolName();\n         assertThat(getValue(\"hikaricp_active_connections\", poolName), is(0.0));\n         assertThat(getValue(\"hikaricp_idle_connections\", poolName), is(0.0));\n         assertThat(getValue(\"hikaricp_pending_threads\", poolName), is(0.0));\n         assertThat(getValue(\"hikaricp_connections\", poolName), is(0.0));\n      }\n      finally {\n         StubConnection.slowCreate = false;\n      }\n   }\n\n   @Test\n   public void connection1() throws Exception {\n      HikariConfig config = newHikariConfig();\n      config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n      config.setMaximumPoolSize(1);\n\n      StubConnection.slowCreate = true;\n      try (HikariDataSource ds = new HikariDataSource(config);\n         Connection connection1 = ds.getConnection()) {\n\n         quietlySleep(1000);\n\n         assertThat(getValue(\"hikaricp_active_connections\", \"connection1\"), is(1.0));\n         assertThat(getValue(\"hikaricp_idle_connections\", \"connection1\"), is(0.0));\n         assertThat(getValue(\"hikaricp_pending_threads\", \"connection1\"), is(0.0));\n         assertThat(getValue(\"hikaricp_connections\", \"connection1\"), is(1.0));\n      }\n      finally {\n         StubConnection.slowCreate = false;\n      }\n   }\n\n   @Test\n   public void connectionClosed() throws Exception {\n      HikariConfig config = newHikariConfig();\n      config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n      config.setMaximumPoolSize(1);\n\n      StubConnection.slowCreate = true;\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         try (Connection connection1 = ds.getConnection()) {\n            // close immediately\n         }\n\n         assertThat(getValue(\"hikaricp_active_connections\", \"connectionClosed\"), is(0.0));\n         assertThat(getValue(\"hikaricp_idle_connections\", \"connectionClosed\"), is(1.0));\n         assertThat(getValue(\"hikaricp_pending_threads\", \"connectionClosed\"), is(0.0));\n         assertThat(getValue(\"hikaricp_connections\", \"connectionClosed\"), is(1.0));\n      }\n      finally {\n         StubConnection.slowCreate = false;\n      }\n   }\n\n   private double getValue(String name, String poolName) {\n      String[] labelNames = {\"pool\"};\n      String[] labelValues = {poolName};\n      return CollectorRegistry.defaultRegistry.getSampleValue(name, labelNames, labelValues);\n   }\n\n}\n"}
{"label": "get|parent|logger", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.mocks;\n\nimport java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.DriverManager;\nimport java.sql.DriverPropertyInfo;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.Properties;\nimport java.util.logging.Logger;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic class StubDriver implements Driver\n{\n    private static final Driver driver;\n\n    static\n    {\n        driver = new StubDriver();\n        try\n        {\n            DriverManager.registerDriver(driver);\n        }\n        catch (SQLException e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public Connection connect(String url, Properties info) throws SQLException\n    {\n        return new StubConnection();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean acceptsURL(String url) throws SQLException\n    {\n        return \"jdbc:stub\".equals(url);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException\n    {\n        return null;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int getMajorVersion()\n    {\n        return 0;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int getMinorVersion()\n    {\n        return 0;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean jdbcCompliant()\n    {\n        return true;\n    }\n\n    /** {@inheritDoc} */\n    public Logger METHOD_NAME() throws SQLFeatureNotSupportedException\n    {\n        return null;\n    }\n}\n"}
{"label": "get|parent|logger", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.mocks;\n\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.io.PrintWriter;\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.sql.Statement;\nimport java.util.logging.Logger;\n\nimport javax.sql.DataSource;\n\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic class MockDataSource implements DataSource\n{\n    @Override\n    public Connection getConnection() throws SQLException\n    {\n        return createMockConnection();\n    }\n\n    @Override\n    public Connection getConnection(String username, String password) throws SQLException\n    {\n        return getConnection();\n    }\n\n    @Override\n    public PrintWriter getLogWriter() throws SQLException\n    {\n        return null;\n    }\n\n    @Override\n    public void setLogWriter(PrintWriter out) throws SQLException\n    {\n    }\n\n    @Override\n    public void setLoginTimeout(int seconds) throws SQLException\n    {\n    }\n\n    @Override\n    public int getLoginTimeout() throws SQLException\n    {\n        return 0;\n    }\n\n    public Logger METHOD_NAME() throws SQLFeatureNotSupportedException\n    {\n        return null;\n    }\n\n    @Override\n    public <T> T unwrap(Class<T> iface) throws SQLException\n    {\n        return null;\n    }\n\n    @Override\n    public boolean isWrapperFor(Class<?> iface) throws SQLException\n    {\n        return false;\n    }\n\n    public static Connection createMockConnection() throws SQLException {\n        // Setup mock connection\n        final Connection mockConnection = mock(Connection.class);\n\n        // Autocommit is always true by default\n        when(mockConnection.getAutoCommit()).thenReturn(true);\n\n        // Handle Connection.createStatement()\n        Statement statement = mock(Statement.class);\n        when(mockConnection.createStatement()).thenReturn(statement);\n        when(mockConnection.createStatement(anyInt(), anyInt())).thenReturn(statement);\n        when(mockConnection.createStatement(anyInt(), anyInt(), anyInt())).thenReturn(statement);\n        when(mockConnection.isValid(anyInt())).thenReturn(true);\n\n        // Handle Connection.prepareStatement()\n        PreparedStatement mockPreparedStatement = mock(PreparedStatement.class);\n        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);\n        when(mockConnection.prepareStatement(anyString(), anyInt())).thenReturn(mockPreparedStatement);\n        when(mockConnection.prepareStatement(anyString(), any(int[].class))).thenReturn(mockPreparedStatement);\n        when(mockConnection.prepareStatement(anyString(), any(String[].class))).thenReturn(mockPreparedStatement);\n        when(mockConnection.prepareStatement(anyString(), anyInt(), anyInt())).thenReturn(mockPreparedStatement);\n        when(mockConnection.prepareStatement(anyString(), anyInt(), anyInt(), anyInt())).thenReturn(mockPreparedStatement);\n        doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable\n            {\n                return null;\n            }\n        }).doNothing().when(mockPreparedStatement).setInt(anyInt(), anyInt());\n\n        ResultSet mockResultSet = mock(ResultSet.class);\n        when(mockPreparedStatement.executeQuery()).thenReturn(mockResultSet);\n        when(mockResultSet.getString(anyInt())).thenReturn(\"aString\");\n        when(mockResultSet.next()).thenReturn(true);\n\n        // Handle Connection.prepareCall()\n        CallableStatement mockCallableStatement = mock(CallableStatement.class);\n        when(mockConnection.prepareCall(anyString())).thenReturn(mockCallableStatement);\n        when(mockConnection.prepareCall(anyString(), anyInt(), anyInt())).thenReturn(mockCallableStatement);\n        when(mockConnection.prepareCall(anyString(), anyInt(), anyInt(), anyInt())).thenReturn(mockCallableStatement);\n\n        // Handle Connection.close()\n//        doAnswer(new Answer<Void>() {\n//            public Void answer(InvocationOnMock invocation) throws Throwable {\n//                return null;\n//            }\n//        }).doThrow(new SQLException(\"Connection is already closed\")).when(mockConnection).close();\n\n        // Handle Connection.commit()\n//        doAnswer(new Answer<Void>() {\n//            public Void answer(InvocationOnMock invocation) throws Throwable {\n//                return null;\n//            }\n//        }).doThrow(new SQLException(\"Transaction already commited\")).when(mockConnection).commit();\n\n        // Handle Connection.rollback()\n//        doAnswer(new Answer<Void>() {\n//            public Void answer(InvocationOnMock invocation) throws Throwable {\n//                return null;\n//            }\n//        }).doThrow(new SQLException(\"Transaction already rolledback\")).when(mockConnection).rollback();\n\n        return mockConnection;\n    }\n}\n"}
{"label": "get|user", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.mocks;\n\nimport com.zaxxer.hikari.util.UtilityElf;\n\nimport java.io.PrintWriter;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.logging.Logger;\n\nimport javax.sql.DataSource;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic class StubDataSource implements DataSource\n{\n   private String user;\n   private String password;\n   private PrintWriter logWriter;\n   private SQLException throwException;\n   private long connectionAcquistionTime = 0;\n   private int loginTimeout;\n\n   public String METHOD_NAME()\n   {\n      return user;\n   }\n\n   public void setUser(String user)\n   {\n      this.user = user;\n   }\n\n   public String getPassword()\n   {\n      return password;\n   }\n\n   public void setPassword(String password)\n   {\n      this.password = password;\n   }\n\n   public void setURL(String url)\n   {\n      // we don't care\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public PrintWriter getLogWriter() throws SQLException\n   {\n      return logWriter;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void setLogWriter(PrintWriter out) throws SQLException\n   {\n      this.logWriter = out;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public void setLoginTimeout(int seconds) throws SQLException\n   {\n      this.loginTimeout = seconds;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public int getLoginTimeout() throws SQLException\n   {\n      return loginTimeout;\n   }\n\n   /** {@inheritDoc} */\n   public Logger getParentLogger() throws SQLFeatureNotSupportedException\n   {\n      return null;\n   }\n\n   /** {@inheritDoc} */\n   @SuppressWarnings(\"unchecked\")\n   @Override\n   public <T> T unwrap(Class<T> iface) throws SQLException\n   {\n      if (iface.isInstance(this)) {\n         return (T) this;\n      }\n\n      throw new SQLException(\"Wrapped DataSource is not an instance of \" + iface);\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public boolean isWrapperFor(Class<?> iface) throws SQLException\n   {\n      return false;\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public Connection getConnection() throws SQLException\n   {\n      if (throwException != null) {\n         throw throwException;\n      }\n      if (connectionAcquistionTime > 0) {\n         UtilityElf.quietlySleep(connectionAcquistionTime);\n      }\n\n      return new StubConnection();\n   }\n\n   /** {@inheritDoc} */\n   @Override\n   public Connection getConnection(String username, String password) throws SQLException\n   {\n      return new StubConnection();\n   }\n\n   public void setThrowException(SQLException e)\n   {\n      this.throwException = e;\n   }\n\n   public void setConnectionAcquistionTime(long connectionAcquisitionTime) {\n      this.connectionAcquistionTime = connectionAcquisitionTime;\n   }\n}\n"}
{"label": "test|concurrent|close", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\n/**\n * @author Matthew Tambara (matthew.tambara@liferay.com)\n */\npublic class ConcurrentCloseConnectionTest\n{\n   @Test\n   public void METHOD_NAME() throws Exception\n   {\n\t  HikariConfig config = newHikariConfig();\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n\t  try (HikariDataSource ds = new HikariDataSource(config);\n\t      final Connection connection = ds.getConnection()) {\n\n\t\t  ExecutorService executorService = Executors.newFixedThreadPool(10);\n\n\t\t  List<Future<?>> futures = new ArrayList<>();\n\n\t\t  for (int i = 0; i < 500; i++) {\n\t\t\t  final PreparedStatement preparedStatement =\n\t\t\t\t  connection.prepareStatement(\"\");\n\n\t\t\t  futures.add(executorService.submit(new Callable<Void>() {\n\n\t\t\t\t  @Override\n\t\t\t\t  public Void call() throws Exception {\n\t\t\t\t\t  preparedStatement.close();\n\n\t\t\t\t\t  return null;\n\t\t\t\t  }\n\n\t\t\t  }));\n\t\t  }\n\n\t\t  executorService.shutdown();\n\n\t\t  for (Future<?> future : futures) {\n\t\t\t  future.get();\n\t\t  }\n\t  }\n   }\n}\n"}
{"label": "before", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport org.junit.After;\nimport org.junit.METHOD_NAME;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.util.UtilityElf;\n\n/**\n * @author Martin St\u0159\u00ed\u017e (striz@raynet.cz)\n */\npublic class HouseKeeperCleanupTest\n{\n\n   private ScheduledThreadPoolExecutor executor;\n\n   @METHOD_NAME\n   public void METHOD_NAME() throws Exception\n   {\n      ThreadFactory threadFactory = new UtilityElf.DefaultThreadFactory(\"global housekeeper\", true);\n\n      executor = new ScheduledThreadPoolExecutor(1, threadFactory, new ThreadPoolExecutor.DiscardPolicy());\n      executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n      executor.setRemoveOnCancelPolicy(true);\n   }\n\n   @Test\n   public void testHouseKeeperCleanupWithCustomExecutor() throws Exception\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(0);\n      config.setMaximumPoolSize(10);\n      config.setInitializationFailTimeout(Long.MAX_VALUE);\n      config.setConnectionTimeout(2500);\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n      config.setScheduledExecutor(executor);\n\n      HikariConfig config2 = newHikariConfig();\n      config.copyStateTo(config2);\n\n      try (\n         final HikariDataSource ds1 = new HikariDataSource(config);\n         final HikariDataSource ds2 = new HikariDataSource(config2)\n      ) {\n         assertEquals(\"Scheduled tasks count not as expected, \", 2, executor.getQueue().size());\n      }\n\n      assertEquals(\"Scheduled tasks count not as expected, \", 0, executor.getQueue().size());\n   }\n\n   @After\n   public void after() throws Exception\n   {\n      executor.shutdown();\n      executor.awaitTermination(5, TimeUnit.SECONDS);\n   }\n\n}\n"}
{"label": "test|codegen", "code": "package com.zaxxer.hikari.pool;\n\nimport com.zaxxer.hikari.mocks.StubConnection;\nimport com.zaxxer.hikari.pool.TestElf.FauxWebClassLoader;\nimport com.zaxxer.hikari.util.JavassistProxyFactory;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.lang.reflect.Method;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.Connection;\nimport java.sql.Statement;\nimport java.util.stream.Stream;\n\npublic class TestJavassistCodegen {\n   @Test\n   public void METHOD_NAME() throws Exception {\n      String tmp = System.getProperty(\"java.io.tmpdir\");\n      JavassistProxyFactory.main(tmp + (tmp.endsWith(\"/\") ? \"\" : \"/\"));\n\n      Path base = Paths.get(tmp, \"target/classes/com/zaxxer/hikari/pool\".split(\"/\"));\n      Assert.assertTrue(\"\", Files.isRegularFile(base.resolve(\"HikariProxyConnection.class\")));\n      Assert.assertTrue(\"\", Files.isRegularFile(base.resolve(\"HikariProxyStatement.class\")));\n      Assert.assertTrue(\"\", Files.isRegularFile(base.resolve(\"HikariProxyCallableStatement.class\")));\n      Assert.assertTrue(\"\", Files.isRegularFile(base.resolve(\"HikariProxyPreparedStatement.class\")));\n      Assert.assertTrue(\"\", Files.isRegularFile(base.resolve(\"HikariProxyResultSet.class\")));\n      Assert.assertTrue(\"\", Files.isRegularFile(base.resolve(\"ProxyFactory.class\")));\n\n      FauxWebClassLoader fauxClassLoader = new FauxWebClassLoader();\n      Class<?> proxyFactoryClass = fauxClassLoader.loadClass(\"com.zaxxer.hikari.pool.ProxyFactory\");\n\n      Connection connection = new StubConnection();\n\n      Class<?> fastListClass = fauxClassLoader.loadClass(\"com.zaxxer.hikari.util.FastList\");\n      Object fastList = fastListClass.getConstructor(Class.class).newInstance(Statement.class);\n\n      Object proxyConnection = getMethod(proxyFactoryClass, \"getProxyConnection\")\n         .invoke(null,\n            null /*poolEntry*/,\n            connection,\n            fastList,\n            null /*leakTask*/,\n            0L /*now*/,\n            Boolean.FALSE /*isReadOnly*/,\n            Boolean.FALSE /*isAutoCommit*/);\n      Assert.assertNotNull(proxyConnection);\n\n      Object proxyStatement = getMethod(proxyConnection.getClass(), \"createStatement\", 0)\n         .invoke(proxyConnection);\n      Assert.assertNotNull(proxyStatement);\n   }\n\n   private Method getMethod(Class<?> clazz, String methodName, Integer... parameterCount)\n   {\n      return Stream.of(clazz.getDeclaredMethods())\n          .filter(method -> method.getName().equals(methodName))\n          .filter(method -> (parameterCount.length == 0 || parameterCount[0] == method.getParameterCount()))\n          .peek(method -> method.setAccessible(true))\n          .findFirst()\n          .orElseThrow(RuntimeException::new);\n   }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\npublic class ExceptionTest\n{\n   private HikariDataSource ds;\n\n   @Before\n   public void METHOD_NAME()\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(1);\n      config.setMaximumPoolSize(2);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      ds = new HikariDataSource(config);\n   }\n\n   @After\n   public void teardown()\n   {\n      ds.close();\n   }\n\n   @Test\n   public void testException1() throws SQLException\n   {\n      try (Connection connection = ds.getConnection()) {\n         assertNotNull(connection);\n\n         PreparedStatement statement = connection.prepareStatement(\"SELECT some, thing FROM somewhere WHERE something=?\");\n         assertNotNull(statement);\n\n         ResultSet resultSet = statement.executeQuery();\n         assertNotNull(resultSet);\n\n         try {\n            statement.getMaxFieldSize();\n            fail();\n         }\n         catch (Exception e) {\n            assertSame(SQLException.class, e.getClass());\n         }\n      }\n\n      HikariPool pool = getPool(ds);\n      assertTrue(\"Total (3) connections not as expected\", pool.getTotalConnections() >= 0);\n      assertTrue(\"Idle (3) connections not as expected\", pool.getIdleConnections() >= 0);\n   }\n\n   @Test\n   public void testUseAfterStatementClose() throws SQLException\n   {\n      Connection connection = ds.getConnection();\n      assertNotNull(connection);\n\n      try (Statement statement = connection.prepareStatement(\"SELECT some, thing FROM somewhere WHERE something=?\")) {\n         statement.close();\n         statement.getMoreResults();\n\n         fail();\n      }\n      catch (SQLException e) {\n         assertSame(\"Connection is closed\", e.getMessage());\n      }\n   }\n\n   @Test\n   public void testUseAfterClose() throws SQLException\n   {\n      try (Connection connection = ds.getConnection()) {\n         assertNotNull(connection);\n         connection.close();\n\n         try (Statement statement = connection.prepareStatement(\"SELECT some, thing FROM somewhere WHERE something=?\")) {\n            fail();\n         }\n         catch (SQLException e) {\n            assertSame(\"Connection is closed\", e.getMessage());\n         }\n      }\n   }\n}\n"}
{"label": "test|unwrap|connection", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.mocks.StubConnection;\nimport com.zaxxer.hikari.mocks.StubDataSource;\n\n/**\n * @author Brett Wooldridge\n */\npublic class UnwrapTest\n{\n    @Test\n    public void METHOD_NAME() throws SQLException\n    {\n        HikariConfig config = newHikariConfig();\n        config.setMinimumIdle(1);\n        config.setMaximumPoolSize(1);\n        config.setInitializationFailTimeout(0);\n        config.setConnectionTestQuery(\"VALUES 1\");\n        config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n       try (HikariDataSource ds = new HikariDataSource(config)) {\n          ds.getConnection().close();\n          assertSame(\"Idle connections not as expected\", 1, getPool(ds).getIdleConnections());\n\n          Connection connection = ds.getConnection();\n          assertNotNull(connection);\n\n          StubConnection unwrapped = connection.unwrap(StubConnection.class);\n          assertTrue(\"unwrapped connection is not instance of StubConnection: \" + unwrapped, (unwrapped != null && unwrapped instanceof StubConnection));\n       }\n    }\n\n    @Test\n    public void testUnwrapDataSource() throws SQLException\n    {\n       HikariConfig config = newHikariConfig();\n       config.setMinimumIdle(1);\n       config.setMaximumPoolSize(1);\n       config.setInitializationFailTimeout(0);\n       config.setConnectionTestQuery(\"VALUES 1\");\n       config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n       try (HikariDataSource ds = new HikariDataSource(config)) {\n          StubDataSource unwrap = ds.unwrap(StubDataSource.class);\n          assertNotNull(unwrap);\n          assertTrue(unwrap instanceof StubDataSource);\n\n          assertTrue(ds.isWrapperFor(HikariDataSource.class));\n          assertTrue(ds.unwrap(HikariDataSource.class) instanceof HikariDataSource);\n\n          assertFalse(ds.isWrapperFor(getClass()));\n          try {\n             ds.unwrap(getClass());\n          }\n          catch (SQLException e) {\n             assertTrue(e.getMessage().contains(\"Wrapped DataSource\"));\n          }\n       }\n    }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\npublic class StatementTest\n{\n   private HikariDataSource ds;\n\n   @Before\n   public void METHOD_NAME()\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(1);\n      config.setMaximumPoolSize(2);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      ds = new HikariDataSource(config);\n   }\n\n   @After\n   public void teardown()\n   {\n      ds.close();\n   }\n\n   @Test\n   public void testStatementClose() throws SQLException\n   {\n      ds.getConnection().close();\n\n      HikariPool pool = getPool(ds);\n      assertTrue(\"Total connections not as expected\", pool.getTotalConnections() >= 1);\n      assertTrue(\"Idle connections not as expected\", pool.getIdleConnections() >= 1);\n\n      try (Connection connection = ds.getConnection()) {\n         assertNotNull(connection);\n\n         assertTrue(\"Total connections not as expected\", pool.getTotalConnections() >= 1);\n         assertTrue(\"Idle connections not as expected\", pool.getIdleConnections() >= 0);\n\n         Statement statement = connection.createStatement();\n         assertNotNull(statement);\n\n         connection.close();\n\n         assertTrue(statement.isClosed());\n      }\n   }\n\n   @Test\n   public void testAutoStatementClose() throws SQLException\n   {\n      try (Connection connection = ds.getConnection()) {\n         assertNotNull(connection);\n\n         Statement statement1 = connection.createStatement();\n         assertNotNull(statement1);\n         Statement statement2 = connection.createStatement();\n         assertNotNull(statement2);\n\n         connection.close();\n\n         assertTrue(statement1.isClosed());\n         assertTrue(statement2.isClosed());\n      }\n   }\n\n   @Test\n   public void testDoubleStatementClose() throws SQLException\n   {\n      try (Connection connection = ds.getConnection();\n            Statement statement1 = connection.createStatement()) {\n         statement1.close();\n         statement1.close();\n      }\n   }\n\n   @Test\n   public void testOutOfOrderStatementClose() throws SQLException\n   {\n      try (Connection connection = ds.getConnection();\n            Statement statement1 = connection.createStatement();\n            Statement statement2 = connection.createStatement()) {\n         statement1.close();\n         statement2.close();\n      }\n   }\n}\n"}
{"label": "connection|timeout|is|recorded", "code": "package com.zaxxer.hikari.pool;\n\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.metrics.IMetricsTracker;\nimport com.zaxxer.hikari.mocks.StubDataSource;\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.SQLTransientConnectionException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariDataSource;\nimport static junit.framework.TestCase.fail;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author wvuong@chariotsolutions.com on 2/16/17.\n */\npublic class MetricsTrackerTest\n{\n\n   @Test(expected = SQLTransientConnectionException.class)\n   public void METHOD_NAME() throws Exception\n   {\n      int timeoutMillis = 1000;\n      int timeToCreateNewConnectionMillis = timeoutMillis * 2;\n\n      StubDataSource stubDataSource = new StubDataSource();\n      stubDataSource.setConnectionAcquistionTime(timeToCreateNewConnectionMillis);\n\n      StubMetricsTracker metricsTracker = new StubMetricsTracker();\n\n      try (HikariDataSource ds = newHikariDataSource()) {\n         ds.setMinimumIdle(0);\n         ds.setMaximumPoolSize(1);\n         ds.setConnectionTimeout(timeoutMillis);\n         ds.setDataSource(stubDataSource);\n         ds.setMetricsTrackerFactory((poolName, poolStats) -> metricsTracker);\n\n         try (Connection c = ds.getConnection()) {\n            fail(\"Connection shouldn't have been successfully created due to configured connection timeout\");\n\n         } finally {\n            // assert that connection timeout was measured\n            assertThat(metricsTracker.connectionTimeoutRecorded, is(true));\n            // assert that measured time to acquire connection should be roughly equal or greater than the configured connection timeout time\n            assertTrue(metricsTracker.connectionAcquiredNanos >= TimeUnit.NANOSECONDS.convert(timeoutMillis, TimeUnit.MILLISECONDS));\n         }\n      }\n   }\n\n   private static class StubMetricsTracker implements IMetricsTracker\n   {\n\n      private Long connectionCreatedMillis;\n      private Long connectionAcquiredNanos;\n      private Long connectionBorrowedMillis;\n      private boolean connectionTimeoutRecorded;\n\n      @Override\n      public void recordConnectionCreatedMillis(long connectionCreatedMillis)\n      {\n         this.connectionCreatedMillis = connectionCreatedMillis;\n      }\n\n      @Override\n      public void recordConnectionAcquiredNanos(long elapsedAcquiredNanos)\n      {\n         this.connectionAcquiredNanos = elapsedAcquiredNanos;\n      }\n\n      @Override\n      public void recordConnectionUsageMillis(long elapsedBorrowedMillis)\n      {\n         this.connectionBorrowedMillis = elapsedBorrowedMillis;\n      }\n\n      @Override\n      public void recordConnectionTimeout()\n      {\n         this.connectionTimeoutRecorded = true;\n      }\n   }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.setSlf4jTargetStream;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.util.ConcurrentBag;\n\n/**\n *\n * @author Brett Wooldridge\n */\npublic class TestConcurrentBag\n{\n   private static HikariDataSource ds;\n   private static HikariPool pool;\n\n   @BeforeClass\n   public static void METHOD_NAME()\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(1);\n      config.setMaximumPoolSize(2);\n      config.setInitializationFailTimeout(0);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      ds = new HikariDataSource(config);\n      pool = getPool(ds);\n   }\n\n   @AfterClass\n   public static void teardown()\n   {\n      ds.close();\n   }\n\n   @Test\n   public void testConcurrentBag() throws Exception\n   {\n      try (ConcurrentBag<PoolEntry> bag = new ConcurrentBag<>((x) -> CompletableFuture.completedFuture(Boolean.TRUE))) {\n         assertEquals(0, bag.values(8).size());\n   \n         PoolEntry reserved = pool.newPoolEntry();\n         bag.add(reserved);\n         bag.reserve(reserved);      // reserved\n   \n         PoolEntry inuse = pool.newPoolEntry();\n         bag.add(inuse);\n         bag.borrow(2, MILLISECONDS); // in use\n   \n         PoolEntry notinuse = pool.newPoolEntry();\n         bag.add(notinuse); // not in use\n   \n         bag.dumpState();\n   \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         PrintStream ps = new PrintStream(baos, true);\n         setSlf4jTargetStream(ConcurrentBag.class, ps);\n   \n         bag.requite(reserved);\n   \n         bag.remove(notinuse);\n         assertTrue(new String(baos.toByteArray()).contains(\"not borrowed or reserved\"));\n   \n         bag.unreserve(notinuse);\n         assertTrue(new String(baos.toByteArray()).contains(\"was not reserved\"));\n   \n         bag.remove(inuse);\n         bag.remove(inuse);\n         assertTrue(new String(baos.toByteArray()).contains(\"not borrowed or reserved\"));\n   \n         bag.close();\n         try {\n            PoolEntry bagEntry = pool.newPoolEntry();\n            bag.add(bagEntry);\n            assertNotEquals(bagEntry, bag.borrow(100, MILLISECONDS));\n         }\n         catch (IllegalStateException e) {\n            assertTrue(new String(baos.toByteArray()).contains(\"ignoring add()\"));\n         }\n   \n         assertNotNull(notinuse.toString());\n      }\n   }\n}\n"}
{"label": "test|connection|provider", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.fail;\n\nimport java.sql.Connection;\nimport java.util.Properties;\n\nimport org.hibernate.service.UnknownUnwrapTypeException;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.hibernate.HikariConnectionProvider;\n\npublic class TestHibernate\n{\n   @Test\n   public void METHOD_NAME() throws Exception\n   {\n      HikariConnectionProvider provider = new HikariConnectionProvider();\n\n      Properties props = new Properties();\n      props.load(getClass().getResourceAsStream(\"/hibernate.properties\"));\n\n      provider.configure(props);\n      Connection connection = provider.getConnection();\n      provider.closeConnection(connection);\n\n      assertNotNull(provider.unwrap(HikariConnectionProvider.class));\n      assertFalse(provider.supportsAggressiveRelease());\n\n      try {\n         provider.unwrap(TestHibernate.class);\n         fail(\"Expected exception\");\n      }\n      catch (UnknownUnwrapTypeException e) {\n      }\n\n      provider.stop();\n   }\n}\n"}
{"label": "test|race|condition", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.setSlf4jLogLevel;\nimport static org.junit.Assert.fail;\n\nimport java.sql.Connection;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.logging.log4j.Level;\nimport org.junit.After;\nimport org.junit.Test;\nimport org.slf4j.LoggerFactory;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.util.ConcurrentBag;\n\n/**\n * @author Matthew Tambara (matthew.tambara@liferay.com)\n */\npublic class ConnectionRaceConditionTest\n{\n\n   public static final int ITERATIONS = 10_000;\n\n   @Test\n   public void METHOD_NAME() throws Exception\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(0);\n      config.setMaximumPoolSize(10);\n      config.setInitializationFailTimeout(Long.MAX_VALUE);\n      config.setConnectionTimeout(5000);\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      setSlf4jLogLevel(ConcurrentBag.class, Level.INFO);\n\n      final AtomicReference<Exception> ref = new AtomicReference<>(null);\n\n      // Initialize HikariPool with no initial connections and room to grow\n      try (final HikariDataSource ds = new HikariDataSource(config)) {\n         ExecutorService threadPool = Executors.newFixedThreadPool(2);\n         for (int i = 0; i < ITERATIONS; i++) {\n            threadPool.submit(new Callable<Exception>() {\n               /** {@inheritDoc} */\n               @Override\n               public Exception call() throws Exception\n               {\n                  if (ref.get() == null) {\n                     Connection c2;\n                     try {\n                        c2 = ds.getConnection();\n                        ds.evictConnection(c2);\n                     }\n                     catch (Exception e) {\n                        ref.set(e);\n                     }\n                  }\n                  return null;\n               }\n            });\n         }\n\n         threadPool.shutdown();\n         threadPool.awaitTermination(30, TimeUnit.SECONDS);\n\n         if (ref.get() != null) {\n            LoggerFactory.getLogger(ConnectionRaceConditionTest.class).error(\"Task failed\", ref.get());\n            fail(\"Task failed\");\n         }\n      }\n      catch (Exception e) {\n         throw e;\n      }\n   }\n\n   @After\n   public void after()\n   {\n      System.getProperties().remove(\"com.zaxxer.hikari.housekeeping.periodMs\");\n\n      setSlf4jLogLevel(HikariPool.class, Level.WARN);\n      setSlf4jLogLevel(ConcurrentBag.class, Level.WARN);\n   }\n}\n"}
{"label": "test|isolation", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariDataSource;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertSame;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariDataSource;\n\npublic class IsolationTest\n{\n   @Test\n   public void METHOD_NAME() throws SQLException\n   {\n      try (HikariDataSource ds = newHikariDataSource()) {\n         ds.setMinimumIdle(1);\n         ds.setMaximumPoolSize(1);\n         ds.setIsolateInternalQueries(true);\n         ds.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n         try (Connection connection = ds.getConnection()) {\n            connection.close();\n\n            try (Connection connection2 = ds.getConnection()) {\n               connection2.close();\n\n               assertNotSame(connection, connection2);\n               assertSame(connection.unwrap(Connection.class), connection2.unwrap(Connection.class));\n            }\n         }\n      }\n   }\n\n   @Test\n   public void testNonIsolation() throws SQLException\n   {\n      try (HikariDataSource ds = newHikariDataSource()) {\n         ds.setMinimumIdle(1);\n         ds.setMaximumPoolSize(1);\n         ds.setIsolateInternalQueries(false);\n         ds.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n         try (Connection connection = ds.getConnection()) {\n            connection.close();\n\n            try (Connection connection2 = ds.getConnection()) {\n               connection2.close();\n\n               assertSame(connection.unwrap(Connection.class), connection2.unwrap(Connection.class));\n            }\n         }\n      }\n   }\n}\n"}
{"label": "ramp|up|down|test", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static com.zaxxer.hikari.util.UtilityElf.quietlySleep;\nimport static org.junit.Assert.assertSame;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\npublic class RampUpDown\n{\n    @Test\n    public void METHOD_NAME() throws SQLException\n    {\n        HikariConfig config = newHikariConfig();\n        config.setMinimumIdle(5);\n        config.setMaximumPoolSize(60);\n        config.setInitializationFailTimeout(0);\n        config.setConnectionTestQuery(\"VALUES 1\");\n        config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n        System.setProperty(\"com.zaxxer.hikari.housekeeping.periodMs\", \"250\");\n\n        try (HikariDataSource ds = new HikariDataSource(config)) {\n\n           ds.setIdleTimeout(1000);\n           HikariPool pool = getPool(ds);\n\n           // wait two housekeeping periods so we don't fail if this part of test runs too quickly\n           quietlySleep(500);\n\n           Assert.assertSame(\"Total connections not as expected\", 5, pool.getTotalConnections());\n\n           Connection[] connections = new Connection[ds.getMaximumPoolSize()];\n           for (int i = 0; i < connections.length; i++)\n           {\n               connections[i] = ds.getConnection();\n           }\n\n           assertSame(\"Total connections not as expected\", 60, pool.getTotalConnections());\n\n           for (Connection connection : connections)\n           {\n               connection.close();\n           }\n\n           quietlySleep(500);\n\n           assertSame(\"Total connections not as expected\", 5, pool.getTotalConnections());\n        }\n    }\n}\n"}
{"label": "test|connection|close|blocking", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n\n/**\n *\n */\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.util.ClockSource.currentTime;\nimport static com.zaxxer.hikari.util.ClockSource.elapsedMillis;\nimport static com.zaxxer.hikari.util.UtilityElf.quietlySleep;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.mocks.MockDataSource;\n\n/**\n * Test for cases when db network connectivity goes down and close is called on existing connections. By default Hikari\n * blocks longer than getMaximumTimeout (it can hang for a lot of time depending on driver timeout settings). Closing\n * async the connections fixes this issue.\n *\n */\npublic class METHOD_NAME {\n   private static volatile boolean shouldFail = false;\n\n   // @Test\n   public void METHOD_NAME() throws SQLException {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(0);\n      config.setMaximumPoolSize(1);\n      config.setConnectionTimeout(1500);\n      config.setDataSource(new CustomMockDataSource());\n\n      long start = currentTime();\n      try (HikariDataSource ds = new HikariDataSource(config);\n            Connection connection = ds.getConnection()) {\n            \n            connection.close();\n   \n            // Hikari only checks for validity for connections with lastAccess > 1000 ms so we sleep for 1001 ms to force\n            // Hikari to do a connection validation which will fail and will trigger the connection to be closed\n            quietlySleep(1100L);\n   \n            shouldFail = true;\n   \n            // on physical connection close we sleep 2 seconds\n            try (Connection connection2 = ds.getConnection()) {   \n               assertTrue(\"Waited longer than timeout\", (elapsedMillis(start) < config.getConnectionTimeout()));\n            }\n      } catch (SQLException e) {\n         assertTrue(\"getConnection failed because close connection took longer than timeout\", (elapsedMillis(start) < config.getConnectionTimeout()));\n      }\n   }\n\n   private static class CustomMockDataSource extends MockDataSource {\n      @Override\n      public Connection getConnection() throws SQLException {\n         Connection mockConnection = super.getConnection();\n         when(mockConnection.isValid(anyInt())).thenReturn(!shouldFail);\n         doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n               if (shouldFail) {\n                  SECONDS.sleep(2);\n               }\n               return null;\n            }\n         }).when(mockConnection).close();\n         return mockConnection;\n      }\n   }\n\n}\n"}
{"label": "teardown", "code": "/*\n * Copyright (C) 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\nimport org.junit.After;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.util.DriverDataSource;\n\npublic class JdbcDriverTest\n{\n   private HikariDataSource ds;\n\n   @After\n   public void METHOD_NAME()\n   {\n      if (ds != null) {\n         ds.close();\n      }\n   }\n\n   @Test\n   public void driverTest1() throws SQLException\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(1);\n      config.setMaximumPoolSize(1);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDriverClassName(\"com.zaxxer.hikari.mocks.StubDriver\");\n      config.setJdbcUrl(\"jdbc:stub\");\n      config.addDataSourceProperty(\"user\", \"bart\");\n      config.addDataSourceProperty(\"password\", \"simpson\");\n\n      ds = new HikariDataSource(config);\n\n      assertTrue(ds.isWrapperFor(DriverDataSource.class));\n\n      DriverDataSource unwrap = ds.unwrap(DriverDataSource.class);\n      assertNotNull(unwrap);\n\n      try (Connection connection = ds.getConnection()) {\n         // test that getConnection() succeeds\n      }\n   }\n\n   @Test\n   public void driverTest2() throws SQLException\n   {\n      HikariConfig config = newHikariConfig();\n\n      config.setMinimumIdle(1);\n      config.setMaximumPoolSize(1);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDriverClassName(\"com.zaxxer.hikari.mocks.StubDriver\");\n      config.setJdbcUrl(\"jdbc:invalid\");\n\n      try {\n         ds = new HikariDataSource(config);\n      }\n      catch (RuntimeException e) {\n         assertTrue(e.getMessage().contains(\"claims to not accept\"));\n      }\n   }\n}\n"}
{"label": "test|log|writer", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zaxxer.hikari.pool;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static com.zaxxer.hikari.pool.TestElf.getPool;\nimport static com.zaxxer.hikari.pool.TestElf.setConfigUnitTest;\nimport static com.zaxxer.hikari.pool.TestElf.setSlf4jLogLevel;\nimport static com.zaxxer.hikari.pool.TestElf.setSlf4jTargetStream;\nimport static com.zaxxer.hikari.util.UtilityElf.createInstance;\nimport static com.zaxxer.hikari.util.UtilityElf.getTransactionIsolation;\nimport static com.zaxxer.hikari.util.UtilityElf.quietlySleep;\nimport static java.util.concurrent.TimeUnit.SECONDS;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.logging.log4j.Level;\nimport org.junit.Test;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\n/**\n * @author Brett Wooldridge\n */\npublic class MiscTest\n{\n   @Test\n   public void METHOD_NAME() throws SQLException\n   {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(0);\n      config.setMaximumPoolSize(4);\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n      setConfigUnitTest(true);\n\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         PrintWriter writer = new PrintWriter(System.out);\n         ds.setLogWriter(writer);\n         assertSame(writer, ds.getLogWriter());\n         assertEquals(\"testLogWriter\", config.getPoolName());\n      }\n      finally\n      {\n         setConfigUnitTest(false);\n      }\n   }\n\n   @Test\n   public void testInvalidIsolation()\n   {\n      try {\n         getTransactionIsolation(\"INVALID\");\n         fail();\n      }\n      catch (Exception e) {\n         assertTrue(e instanceof IllegalArgumentException);\n      }\n   }\n\n   @Test\n   public void testCreateInstance()\n   {\n      try {\n         createInstance(\"invalid\", null);\n         fail();\n      }\n      catch (RuntimeException e) {\n         assertTrue(e.getCause() instanceof ClassNotFoundException);\n      }\n   }\n\n   @Test\n   public void testLeakDetection() throws Exception\n   {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      try (PrintStream ps = new PrintStream(baos, true)) {\n         setSlf4jTargetStream(Class.forName(\"com.zaxxer.hikari.pool.ProxyLeakTask\"), ps);\n         setConfigUnitTest(true);\n\n         HikariConfig config = newHikariConfig();\n         config.setMinimumIdle(0);\n         config.setMaximumPoolSize(4);\n         config.setThreadFactory(Executors.defaultThreadFactory());\n         config.setMetricRegistry(null);\n         config.setLeakDetectionThreshold(TimeUnit.SECONDS.toMillis(1));\n         config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n         try (HikariDataSource ds = new HikariDataSource(config)) {\n            setSlf4jLogLevel(HikariPool.class, Level.DEBUG);\n            getPool(ds).logPoolState();\n\n            try (Connection connection = ds.getConnection()) {\n               quietlySleep(SECONDS.toMillis(4));\n               connection.close();\n               quietlySleep(SECONDS.toMillis(1));\n               ps.close();\n               String s = new String(baos.toByteArray());\n               assertNotNull(\"Exception string was null\", s);\n               assertTrue(\"Expected exception to contain 'Connection leak detection' but contains *\" + s + \"*\", s.contains(\"Connection leak detection\"));\n            }\n         }\n         finally\n         {\n            setConfigUnitTest(false);\n            setSlf4jLogLevel(HikariPool.class, Level.INFO);\n         }\n      }\n   }\n}\n"}
{"label": "test|m|bean|registration", "code": "/*\n * Copyright (C) 2013, 2014 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.zaxxer.hikari.pool;\n\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport com.zaxxer.hikari.HikariPoolMXBean;\nimport org.junit.Test;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.ObjectName;\nimport java.lang.management.ManagementFactory;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.zaxxer.hikari.pool.TestElf.newHikariConfig;\nimport static org.junit.Assert.assertEquals;\n\npublic class TestMBean\n{\n   @Test\n   public void METHOD_NAME() throws SQLException {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(0);\n      config.setMaximumPoolSize(1);\n      config.setRegisterMbeans(true);\n      config.setConnectionTimeout(2800);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n         // Close immediately\n      }\n   }\n\n   @Test\n   public void testMBeanReporting() throws SQLException, InterruptedException, MalformedObjectNameException {\n      HikariConfig config = newHikariConfig();\n      config.setMinimumIdle(3);\n      config.setMaximumPoolSize(5);\n      config.setRegisterMbeans(true);\n      config.setConnectionTimeout(2800);\n      config.setConnectionTestQuery(\"VALUES 1\");\n      config.setDataSourceClassName(\"com.zaxxer.hikari.mocks.StubDataSource\");\n\n      System.setProperty(\"com.zaxxer.hikari.housekeeping.periodMs\", \"100\");\n\n      try (HikariDataSource ds = new HikariDataSource(config)) {\n\n         ds.setIdleTimeout(3000);\n\n         TimeUnit.SECONDS.sleep(1);\n\n         MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n         ObjectName poolName = new ObjectName(\"com.zaxxer.hikari:type=Pool (testMBeanReporting)\");\n         HikariPoolMXBean hikariPoolMXBean = JMX.newMXBeanProxy(mBeanServer, poolName, HikariPoolMXBean.class);\n\n         assertEquals(0, hikariPoolMXBean.getActiveConnections());\n         assertEquals(3, hikariPoolMXBean.getIdleConnections());\n\n         try (Connection connection = ds.getConnection()) {\n            assertEquals(1, hikariPoolMXBean.getActiveConnections());\n\n            TimeUnit.SECONDS.sleep(1);\n\n            assertEquals(3, hikariPoolMXBean.getIdleConnections());\n            assertEquals(4, hikariPoolMXBean.getTotalConnections());\n         }\n\n         TimeUnit.SECONDS.sleep(2);\n\n         assertEquals(0, hikariPoolMXBean.getActiveConnections());\n         assertEquals(3, hikariPoolMXBean.getIdleConnections());\n         assertEquals(3, hikariPoolMXBean.getTotalConnections());\n\n      }\n      finally {\n         System.clearProperty(\"com.zaxxer.hikari.housekeeping.periodMs\");\n      }\n   }\n}\n"}
{"label": "check|inject", "code": "/*\n * Copyright (C) 2013 Brett Wooldridge\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.zaxxer.hikari.osgi;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runner.manipulation.Filter;\nimport org.junit.runner.manipulation.NoTestsRemainException;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.model.InitializationError;\nimport org.ops4j.pax.exam.Configuration;\nimport org.ops4j.pax.exam.Option;\nimport org.ops4j.pax.exam.junit.PaxExam;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\n\nimport javax.inject.Inject;\nimport java.io.File;\n\nimport static com.zaxxer.hikari.pool.TestElf.isJava9;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.ops4j.pax.exam.CoreOptions.*;\n\n/**\n * @author lburgazzoli\n */\n@RunWith(OSGiBundleTest.ConditionalPaxExam.class)\npublic class OSGiBundleTest\n{\n   @Test\n   public void METHOD_NAME()\n   {\n      assertNotNull(context);\n   }\n\n   @Test\n   public void checkBundle()\n   {\n      Boolean bundleFound = false;\n      Boolean bundleActive = false;\n\n      Bundle[] bundles = context.getBundles();\n      for (Bundle bundle : bundles) {\n         if (bundle != null) {\n            if (bundle.getSymbolicName().equals(\"com.zaxxer.HikariCP\")) {\n               bundleFound = true;\n               if (bundle.getState() == Bundle.ACTIVE) {\n                  bundleActive = true;\n               }\n            }\n         }\n      }\n\n      assertTrue(bundleFound);\n      assertTrue(bundleActive);\n   }\n\n   @Inject\n   BundleContext context;\n\n   @Configuration\n   public Option[] config()\n   {\n      return options(\n         systemProperty(\"org.osgi.framework.storage.clean\").value(\"true\"),\n         systemProperty(\"org.ops4j.pax.logging.DefaultServiceLog.level\").value(\"WARN\"),\n         mavenBundle(\"org.slf4j\", \"slf4j-api\", \"1.7.5\"),\n         mavenBundle(\"org.slf4j\", \"slf4j-simple\", \"1.7.5\").noStart(),\n         new File(\"target/classes\").exists()\n            ? bundle(\"reference:file:target/classes\")\n            : bundle(\"reference:file:../target/classes\"),\n         junitBundles(),\n         cleanCaches()\n      );\n   }\n\n   public static class ConditionalPaxExam extends PaxExam\n   {\n      public ConditionalPaxExam(Class<?> klass) throws InitializationError {\n         super(klass);\n      }\n\n      @Override\n      public void run(RunNotifier notifier) {\n         if (!isJava9()) {\n            super.run(notifier);\n         }\n      }\n\n      @Override\n      public void filter(Filter filter) throws NoTestsRemainException {\n         if (isJava9()) {\n            throw new NoTestsRemainException();\n         }\n\n         super.filter(filter);\n      }\n   }\n}\n"}
{"label": "add|slider", "code": "package com.daimajia.slider.library;\n\nimport android.content.Context;\nimport android.support.v4.view.PagerAdapter;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport com.daimajia.slider.library.SliderTypes.BaseSliderView;\n\nimport java.util.ArrayList;\n\n/**\n * A slider adapter\n */\npublic class SliderAdapter extends PagerAdapter implements BaseSliderView.ImageLoadListener{\n\n    private Context mContext;\n    private ArrayList<BaseSliderView> mImageContents;\n\n    public SliderAdapter(Context context){\n        mContext = context;\n        mImageContents = new ArrayList<BaseSliderView>();\n    }\n\n    public <T extends BaseSliderView> void METHOD_NAME(T slider){\n        slider.setOnImageLoadListener(this);\n        mImageContents.add(slider);\n        notifyDataSetChanged();\n    }\n\n    public BaseSliderView getSliderView(int position){\n        if(position < 0 || position >= mImageContents.size()){\n            return null;\n        }else{\n            return mImageContents.get(position);\n        }\n    }\n\n    @Override\n    public int getItemPosition(Object object) {\n        return POSITION_NONE;\n    }\n\n    public <T extends BaseSliderView> void removeSlider(T slider){\n        if(mImageContents.contains(slider)){\n            mImageContents.remove(slider);\n            notifyDataSetChanged();\n        }\n    }\n\n    public void removeSliderAt(int position){\n        if(mImageContents.size() > position){\n            mImageContents.remove(position);\n            notifyDataSetChanged();\n        }\n    }\n\n    public void removeAllSliders(){\n        mImageContents.clear();\n        notifyDataSetChanged();\n    }\n\n    @Override\n    public int getCount() {\n        return mImageContents.size();\n    }\n\n    @Override\n    public boolean isViewFromObject(View view, Object object) {\n        return view==object;\n    }\n\n    @Override\n    public void destroyItem(ViewGroup container, int position, Object object) {\n        container.removeView((View) object);\n    }\n\n    @Override\n    public Object instantiateItem(ViewGroup container, int position) {\n        BaseSliderView b = mImageContents.get(position);\n        View v = b.getView();\n        container.addView(v);\n        return v;\n    }\n\n    @Override\n    public void onStart(BaseSliderView target) {\n\n    }\n\n    /**\n     * When image download error, then remove.\n     * @param result\n     * @param target\n     */\n    @Override\n    public void onEnd(boolean result, BaseSliderView target) {\n        if(target.isErrorDisappear() == false || result == true){\n            return;\n        }\n        for (BaseSliderView slider: mImageContents){\n            if(slider.equals(target)){\n                removeSlider(target);\n                break;\n            }\n        }\n    }\n\n}\n"}
{"label": "get|real|adapter", "code": "package com.daimajia.slider.library.Tricks;\n\nimport android.os.Parcelable;\nimport android.support.v4.view.PagerAdapter;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport com.daimajia.slider.library.SliderAdapter;\n\n/**\n * A PagerAdapter that wraps around another PagerAdapter to handle paging wrap-around.\n * Thanks to: https://github.com/antonyt/InfiniteViewPager\n */\npublic class InfinitePagerAdapter extends PagerAdapter {\n\n    private static final String TAG = \"InfinitePagerAdapter\";\n    private static final boolean DEBUG = false;\n\n    private SliderAdapter adapter;\n\n    public InfinitePagerAdapter(SliderAdapter adapter) {\n        this.adapter = adapter;\n    }\n\n    public SliderAdapter METHOD_NAME(){\n        return this.adapter;\n    }\n\n    @Override\n    public int getCount() {\n        // warning: scrolling to very high values (1,000,000+) results in\n        // strange drawing behaviour\n        return Integer.MAX_VALUE;\n    }\n\n    /**\n     * @return the {@link #getCount()} result of the wrapped adapter\n     */\n    public int getRealCount() {\n        return adapter.getCount();\n    }\n\n    @Override\n    public Object instantiateItem(ViewGroup container, int position) {\n        if(getRealCount() == 0){\n            return null;\n        }\n        int virtualPosition = position % getRealCount();\n        debug(\"instantiateItem: real position: \" + position);\n        debug(\"instantiateItem: virtual position: \" + virtualPosition);\n\n        // only expose virtual position to the inner adapter\n        return adapter.instantiateItem(container, virtualPosition);\n    }\n\n    @Override\n    public void destroyItem(ViewGroup container, int position, Object object) {\n        if(getRealCount() == 0){\n            return;\n        }\n        int virtualPosition = position % getRealCount();\n        debug(\"destroyItem: real position: \" + position);\n        debug(\"destroyItem: virtual position: \" + virtualPosition);\n\n        // only expose virtual position to the inner adapter\n        adapter.destroyItem(container, virtualPosition, object);\n    }\n\n    /*\n     * Delegate rest of methods directly to the inner adapter.\n     */\n\n    @Override\n    public void finishUpdate(ViewGroup container) {\n        adapter.finishUpdate(container);\n    }\n\n    @Override\n    public boolean isViewFromObject(View view, Object object) {\n        return adapter.isViewFromObject(view, object);\n    }\n\n    @Override\n    public void restoreState(Parcelable bundle, ClassLoader classLoader) {\n        adapter.restoreState(bundle, classLoader);\n    }\n\n    @Override\n    public Parcelable saveState() {\n        return adapter.saveState();\n    }\n\n    @Override\n    public void startUpdate(ViewGroup container) {\n        adapter.startUpdate(container);\n    }\n\n    /*\n     * End delegation\n     */\n\n    private void debug(String message) {\n        if (DEBUG) {\n            Log.d(TAG, message);\n        }\n    }\n}"}
{"label": "min", "code": "package com.daimajia.slider.library.Transformers;\n\nimport android.view.View;\n\nimport com.nineoldandroids.view.ViewHelper;\n\npublic class BackgroundToForegroundTransformer extends BaseTransformer {\n\n\t@Override\n\tprotected void onTransform(View view, float position) {\n\t\tfinal float height = view.getHeight();\n\t\tfinal float width = view.getWidth();\n\t\tfinal float scale = METHOD_NAME(position < 0 ? 1f : Math.abs(1f - position), 0.5f);\n\n        ViewHelper.setScaleX(view,scale);\n        ViewHelper.setScaleY(view,scale);\n        ViewHelper.setPivotX(view,width*0.5f);\n        ViewHelper.setPivotY(view,height*0.5f);\n        ViewHelper.setTranslationX(view,position < 0 ? width * position : -width * position * 0.25f);\n\t}\n\n\tprivate static final float METHOD_NAME(float val, float METHOD_NAME) {\n\t\treturn val < METHOD_NAME ? METHOD_NAME : val;\n\t}\n\n}\n"}
{"label": "set|visibility", "code": "package com.daimajia.slider.library.Transformers;\n\nimport android.os.Build;\nimport android.view.View;\n\nimport com.daimajia.slider.library.Tricks.ViewPagerEx;\nimport com.nineoldandroids.view.ViewHelper;\n\npublic class FlipPageViewTransformer extends BaseTransformer {\n\n    @Override\n    protected void onTransform(View view, float position) {\n        float percentage = 1 - Math.abs(position);\n        if(Build.VERSION.SDK_INT >= 13){\n            view.setCameraDistance(12000);\n        }\n        METHOD_NAME(view, position);\n        setTranslation(view);\n        setSize(view, position, percentage);\n        setRotation(view, position, percentage);\n    }\n\n    private void METHOD_NAME(View page, float position) {\n        if (position < 0.5 && position > -0.5) {\n            page.METHOD_NAME(View.VISIBLE);\n        } else {\n            page.METHOD_NAME(View.INVISIBLE);\n        }\n    }\n\n    private void setTranslation(View view) {\n        ViewPagerEx viewPager = (ViewPagerEx) view.getParent();\n        int scroll = viewPager.getScrollX() - view.getLeft();\n        ViewHelper.setTranslationX(view,scroll);\n    }\n\n    private void setSize(View view, float position, float percentage) {\n        ViewHelper.setScaleX(view,(position != 0 && position != 1) ? percentage : 1);\n        ViewHelper.setScaleY(view,(position != 0 && position != 1) ? percentage : 1);\n    }\n\n    private void setRotation(View view, float position, float percentage) {\n        if (position > 0) {\n            ViewHelper.setRotationY(view,-180 * (percentage + 1));\n        } else {\n            ViewHelper.setRotationY(view,180 * (percentage + 1));\n        }\n    }\n}"}
{"label": "hide|offscreen|pages", "code": "package com.daimajia.slider.library.Transformers;\n\nimport android.view.View;\n\nimport com.daimajia.slider.library.Animations.BaseAnimationInterface;\nimport com.daimajia.slider.library.Tricks.ViewPagerEx;\nimport com.nineoldandroids.view.ViewHelper;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n/**\n * This is all transformers father.\n *\n * BaseTransformer implement {@link com.daimajia.slider.library.Tricks.ViewPagerEx.PageTransformer}\n * which is just same as {@link android.support.v4.view.ViewPager.PageTransformer}.\n *\n * After you call setPageTransformer(), transformPage() will be called by {@link com.daimajia.slider.library.Tricks.ViewPagerEx}\n * when your slider are animating.\n *\n * In onPreTransform() function, that will make {@link com.daimajia.slider.library.Animations.BaseAnimationInterface}\n * work.\n *\n * if you want to make an acceptable transformer, please do not forget to extend from this class.\n */\npublic abstract class BaseTransformer implements ViewPagerEx.PageTransformer {\n\n    private BaseAnimationInterface mCustomAnimationInterface;\n\n    /**\n     * Called each {@link #transformPage(View, float)}.\n     *\n     * @param view\n     * @param position\n     */\n    protected abstract void onTransform(View view, float position);\n\n    private HashMap<View,ArrayList<Float>> h = new HashMap<View, ArrayList<Float>>();\n\n    @Override\n    public void transformPage(View view, float position) {\n        onPreTransform(view, position);\n        onTransform(view, position);\n        onPostTransform(view, position);\n    }\n\n    /**\n     * If the position offset of a fragment is less than negative one or greater than one, returning true will set the\n     * visibility of the fragment to {@link View#GONE}. Returning false will force the fragment to {@link View#VISIBLE}.\n     *\n     * @return\n     */\n    protected boolean METHOD_NAME() {\n        return true;\n    }\n\n    /**\n     * Indicates if the default animations of the view pager should be used.\n     *\n     * @return\n     */\n    protected boolean isPagingEnabled() {\n        return false;\n    }\n\n    /**\n     * Called each {@link #transformPage(View, float)} before {{@link #onTransform(View, float)} is called.\n     *\n     * @param view\n     * @param position\n     */\n    protected void onPreTransform(View view, float position) {\n        final float width = view.getWidth();\n\n        ViewHelper.setRotationX(view,0);\n        ViewHelper.setRotationY(view,0);\n        ViewHelper.setRotation(view,0);\n        ViewHelper.setScaleX(view,1);\n        ViewHelper.setScaleY(view,1);\n        ViewHelper.setPivotX(view,0);\n        ViewHelper.setPivotY(view,0);\n        ViewHelper.setTranslationY(view,0);\n        ViewHelper.setTranslationX(view,isPagingEnabled() ? 0f : -width * position);\n\n        if (METHOD_NAME()) {\n            ViewHelper.setAlpha(view,position <= -1f || position >= 1f ? 0f : 1f);\n        } else {\n            ViewHelper.setAlpha(view,1f);\n        }\n        if(mCustomAnimationInterface != null){\n            if(h.containsKey(view) == false || h.get(view).size() == 1){\n                if(position > -1 && position < 1){\n                    if(h.get(view) == null){\n                        h.put(view,new ArrayList<Float>());\n                    }\n                    h.get(view).add(position);\n                    if(h.get(view).size() == 2){\n                        float zero = h.get(view).get(0);\n                        float cha = h.get(view).get(1) - h.get(view).get(0);\n                        if(zero > 0){\n                            if(cha > -1 && cha < 0){\n                                //in\n                                mCustomAnimationInterface.onPrepareNextItemShowInScreen(view);\n                            }else{\n                                //out\n                                mCustomAnimationInterface.onPrepareCurrentItemLeaveScreen(view);\n                            }\n                        }else{\n                            if(cha > -1 && cha < 0){\n                                //out\n                                mCustomAnimationInterface.onPrepareCurrentItemLeaveScreen(view);\n                            }else{\n                                //in\n                                mCustomAnimationInterface.onPrepareNextItemShowInScreen(view);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    boolean isApp,isDis;\n    /**\n     * Called each {@link #transformPage(View, float)} call after {@link #onTransform(View, float)} is finished.\n     *\n     * @param view\n     * @param position\n     */\n    protected void onPostTransform(View view, float position) {\n        if(mCustomAnimationInterface != null){\n            if(position == -1 || position == 1){\n                mCustomAnimationInterface.onCurrentItemDisappear(view);\n                isApp = true;\n            }else if(position == 0){\n                mCustomAnimationInterface.onNextItemAppear(view);\n                isDis = true;\n            }\n            if(isApp && isDis){\n                h.clear();\n                isApp = false;\n                isDis = false;\n            }\n        }\n    }\n\n\n    public void setCustomAnimationInterface(BaseAnimationInterface animationInterface){\n        mCustomAnimationInterface = animationInterface;\n    }\n\n}"}
{"label": "min", "code": "package com.daimajia.slider.library.Transformers;\n\nimport android.view.View;\n\nimport com.nineoldandroids.view.ViewHelper;\n\npublic class ForegroundToBackgroundTransformer extends BaseTransformer {\n\n\t@Override\n\tprotected void onTransform(View view, float position) {\n\t\tfinal float height = view.getHeight();\n\t\tfinal float width = view.getWidth();\n\t\tfinal float scale = METHOD_NAME(position > 0 ? 1f : Math.abs(1f + position), 0.5f);\n\n\t\tViewHelper.setScaleX(view,scale);\n        ViewHelper.setScaleY(view,scale);\n        ViewHelper.setPivotX(view,width * 0.5f);\n        ViewHelper.setPivotY(view,height * 0.5f);\n        ViewHelper.setTranslationX(view,position > 0 ? width * position : -width * position * 0.25f);\n\t}\n\n\tprivate static final float METHOD_NAME(float val, float METHOD_NAME) {\n\t\treturn val < METHOD_NAME ? METHOD_NAME : val;\n\t}\n\n}\n"}
{"label": "get|offset|x|for|rotation", "code": "package com.daimajia.slider.library.Transformers;\n\nimport android.graphics.Camera;\nimport android.graphics.Matrix;\nimport android.view.View;\n\nimport com.nineoldandroids.view.ViewHelper;\n\npublic class TabletTransformer extends BaseTransformer {\n\n\tprivate static final Matrix OFFSET_MATRIX = new Matrix();\n\tprivate static final Camera OFFSET_CAMERA = new Camera();\n\tprivate static final float[] OFFSET_TEMP_FLOAT = new float[2];\n\n\t@Override\n\tprotected void onTransform(View view, float position) {\n\t\tfinal float rotation = (position < 0 ? 30f : -30f) * Math.abs(position);\n\n\t\tViewHelper.setTranslationX(view,METHOD_NAME(rotation, view.getWidth(), view.getHeight()));\n        ViewHelper.setPivotX(view,view.getWidth() * 0.5f);\n        ViewHelper.setPivotY(view,0);\n        ViewHelper.setRotationY(view,rotation);\n\t}\n\n\tprotected static final float METHOD_NAME(float degrees, int width, int height) {\n\t\tOFFSET_MATRIX.reset();\n\t\tOFFSET_CAMERA.save();\n\t\tOFFSET_CAMERA.rotateY(Math.abs(degrees));\n\t\tOFFSET_CAMERA.getMatrix(OFFSET_MATRIX);\n\t\tOFFSET_CAMERA.restore();\n\n\t\tOFFSET_MATRIX.preTranslate(-width * 0.5f, -height * 0.5f);\n\t\tOFFSET_MATRIX.postTranslate(width * 0.5f, height * 0.5f);\n\t\tOFFSET_TEMP_FLOAT[0] = width;\n\t\tOFFSET_TEMP_FLOAT[1] = height;\n\t\tOFFSET_MATRIX.mapPoints(OFFSET_TEMP_FLOAT);\n\t\treturn (width - OFFSET_TEMP_FLOAT[0]) * (degrees > 0.0f ? 1.0f : -1.0f);\n\t}\n\n}\n"}
{"label": "log|insert", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport com.facebook.litho.sections.logger.SectionsDebugLogger;\nimport com.facebook.litho.widget.RenderInfo;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Logger implements SectionsDebugLogger {\n\n  protected Set<SectionsDebugLogger> mSectionsDebugLoggers;\n\n  public Logger(Collection<SectionsDebugLogger> sectionsDebugLoggers) {\n    mSectionsDebugLoggers = new HashSet<>();\n    if (sectionsDebugLoggers != null) {\n      for (SectionsDebugLogger sectionsDebugLogger : sectionsDebugLoggers) {\n        if (sectionsDebugLogger != null) {\n          mSectionsDebugLoggers.add(sectionsDebugLogger);\n        }\n      }\n    }\n  }\n\n  public void METHOD_NAME(String tag, int index, RenderInfo renderInfo, String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.METHOD_NAME(tag, index, renderInfo, thread);\n    }\n  }\n\n  public void logUpdate(String tag, int index, RenderInfo renderInfo, String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.logUpdate(tag, index, renderInfo, thread);\n    }\n  }\n\n  public void logDelete(String tag, int index, String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.logDelete(tag, index, thread);\n    }\n  }\n\n  public void logRequestFocus(String tag, int index, RenderInfo renderInfo, String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.logRequestFocus(tag, index, renderInfo, thread);\n    }\n  }\n\n  @Override\n  public void logRequestFocusWithOffset(\n      String tag, int index, int offset, RenderInfo renderInfo, String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.logRequestFocusWithOffset(tag, index, offset, renderInfo, thread);\n    }\n  }\n\n  public void logMove(String tag, int fromPosition, int toPosition, String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.logMove(tag, fromPosition, toPosition, thread);\n    }\n  }\n\n  public void logShouldUpdate(\n      String tag,\n      Object previous,\n      Object next,\n      String previousPrefix,\n      String nextPrefix,\n      Boolean shouldUpdate,\n      String thread) {\n    for (SectionsDebugLogger sectionsDebugLogger : mSectionsDebugLoggers) {\n      sectionsDebugLogger.logShouldUpdate(\n          tag, previous, next, previousPrefix, nextPrefix, shouldUpdate, thread);\n    }\n  }\n}\n"}
{"label": "on|create|change|set", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.common;\n\nimport com.facebook.litho.Component;\nimport com.facebook.litho.Diff;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.sections.ChangeSet;\nimport com.facebook.litho.sections.SectionContext;\nimport com.facebook.litho.sections.annotations.DiffSectionSpec;\nimport com.facebook.litho.sections.annotations.OnDiff;\nimport com.facebook.litho.widget.ComponentRenderInfo;\n\n@DiffSectionSpec\npublic class SingleComponentSectionSpec {\n\n  @OnDiff\n  public static void METHOD_NAME(\n      SectionContext context,\n      ChangeSet changeSet,\n      @Prop Diff<Component> component,\n      @Prop(optional = true) Diff<Boolean> sticky,\n      @Prop(optional = true) Diff<Integer> spanSize) {\n\n    if (component.getNext() == null) {\n      changeSet.delete(0);\n      return;\n    }\n\n    boolean isNextSticky = false;\n    if (sticky != null && sticky.getNext() != null) {\n      isNextSticky = sticky.getNext();\n    }\n\n    int nextSpanSize = 1;\n    if (spanSize != null && spanSize.getNext() != null) {\n      nextSpanSize = spanSize.getNext();\n    }\n\n    if (component.getPrevious() == null) {\n      changeSet.insert(\n          0,\n          ComponentRenderInfo.create()\n              .component(component.getNext())\n              .isSticky(isNextSticky)\n              .spanSize(nextSpanSize)\n              .build());\n      return;\n    }\n\n    // Check if update is required.\n    boolean isPrevSticky = false;\n    if (sticky != null && sticky.getPrevious() != null) {\n      isPrevSticky = sticky.getPrevious();\n    }\n\n    int prevSpanSize = 1;\n    if (spanSize != null && spanSize.getPrevious() != null) {\n      prevSpanSize = spanSize.getPrevious();\n    }\n\n    if (isPrevSticky != isNextSticky\n        || prevSpanSize != nextSpanSize\n        || !component.getPrevious().isEquivalentTo(component.getNext())) {\n      changeSet.update(\n          0,\n          ComponentRenderInfo.create()\n              .component(component.getNext())\n              .isSticky(isNextSticky)\n              .spanSize(nextSpanSize)\n              .build());\n    }\n  }\n}\n"}
{"label": "on|create|initial|state", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.common;\n\nimport android.os.Bundle;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.EventHandler;\nimport com.facebook.litho.StateValue;\nimport com.facebook.litho.annotations.FromEvent;\nimport com.facebook.litho.annotations.METHOD_NAME;\nimport com.facebook.litho.annotations.OnEvent;\nimport com.facebook.litho.annotations.OnUpdateState;\nimport com.facebook.litho.annotations.Param;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.State;\nimport com.facebook.litho.sections.Children;\nimport com.facebook.litho.sections.Section;\nimport com.facebook.litho.sections.SectionContext;\nimport com.facebook.litho.sections.annotations.GroupSectionSpec;\nimport com.facebook.litho.sections.annotations.OnCreateChildren;\nimport com.facebook.litho.widget.RenderInfo;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n\n/**\n * A {@link HideableDataDiffSectionSpec} that wraps a {@link DataDiffSectionSpec}.\n * It provides the ability to remove an item from the DataDiffSection via the\n * {@link HideItemEvent}.\n * This {@link Section} emits the following events:\n *\n *   {@link RenderWithHideItemHandlerEvent} whenever it needs a {@link Component} to render a model T from\n *   the list of data.  A {@link HideItemEvent} handler is a param of this event.\n *   Providing an handler for this {@link OnEvent} is mandatory.\n *\n *   {@link GetUniqueIdentifierEvent} is fired when a single unique identifier is needed for a\n *   model object.\n *\n */\n@GroupSectionSpec(events = {\n    RenderWithHideItemHandlerEvent.class,\n    GetUniqueIdentifierEvent.class})\npublic class HideableDataDiffSectionSpec<T> {\n\n  @METHOD_NAME\n  public static <T> void METHOD_NAME(\n      SectionContext c,\n      StateValue<HashSet> blacklistState) {\n    blacklistState.set(new HashSet());\n  }\n\n  @OnUpdateState\n  public static void onBlacklistUpdate(\n      StateValue<HashSet> blacklistState,\n      @Param Object modelObject,\n      @Param EventHandler<GetUniqueIdentifierEvent> getUniqueIdentifierHandlerParam) {\n    HashSet<Object> newSet = new HashSet<>(blacklistState.get());\n    newSet.add(HideableDataDiffSection.dispatchGetUniqueIdentifierEvent(\n        getUniqueIdentifierHandlerParam, modelObject));\n    blacklistState.set(newSet);\n  }\n\n  @OnCreateChildren\n  protected static <T> Children onCreateChildren(\n      SectionContext c,\n      @State HashSet blacklistState,\n      @Prop List<T> data,\n      @Prop EventHandler<GetUniqueIdentifierEvent> getUniqueIdentifierHandler,\n      @Prop(optional = true) EventHandler<OnCheckIsSameItemEvent> onSameItemEventHandler,\n      @Prop(optional = true) EventHandler<OnCheckIsSameContentEvent> onSameContentEventHandler) {\n    return Children.create()\n        .child(DataDiffSection.<T>create(c)\n            .data(removeBlacklistedItems(\n                c,\n                data,\n                blacklistState,\n                getUniqueIdentifierHandler))\n            .renderEventHandler(HideableDataDiffSection.onRenderEvent(c))\n            .onCheckIsSameContentEventHandler(onSameContentEventHandler)\n            .onCheckIsSameItemEventHandler(onSameItemEventHandler))\n        .build();\n  }\n\n  private static <T> List<T> removeBlacklistedItems(\n      SectionContext c,\n      List<T> data,\n      HashSet blacklist,\n      EventHandler<GetUniqueIdentifierEvent> getItemUniqueIdentifierHandler) {\n    ArrayList<T> builder = new ArrayList<>();\n    final int size = data.size();\n    for (int i = 0; i < size; i++) {\n      final T model = data.get(i);\n      if (!blacklist.contains(\n          HideableDataDiffSection.dispatchGetUniqueIdentifierEvent(\n              getItemUniqueIdentifierHandler,\n              model))) {\n        builder.add(model);\n      }\n    }\n\n    return builder;\n  }\n\n  @OnEvent(RenderEvent.class)\n  protected static RenderInfo onRenderEvent(\n      SectionContext c,\n      @FromEvent int index,\n      @FromEvent Object model,\n      @FromEvent Bundle loggingExtras,\n      @Prop EventHandler<RenderWithHideItemHandlerEvent> renderWithHideItemHandler) {\n    return HideableDataDiffSection.dispatchRenderWithHideItemHandlerEvent(\n        renderWithHideItemHandler,\n        index,\n        model,\n        HideableDataDiffSection.onHideItem(c),\n        loggingExtras);\n  }\n\n  @OnEvent(HideItemEvent.class)\n  public static void onHideItem(\n      SectionContext c,\n      @FromEvent Object model,\n      @Prop EventHandler<GetUniqueIdentifierEvent> getUniqueIdentifierHandler) {\n    HideableDataDiffSection.onBlacklistUpdate(c, model, getUniqueIdentifierHandler);\n  }\n}\n"}
{"label": "create", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport static android.support.v4.util.Pools.SynchronizedPool;\n\nimport android.support.annotation.Nullable;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.v4.util.Pools.Pool;\nimport com.facebook.litho.sections.annotations.GroupSectionSpec;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Utility class that represents the children of a {@link GroupSectionSpec}. This is used to mimic\n * litho's usage of the Container class in {@link com.facebook.litho.annotations.LayoutSpec}'s API\n */\npublic class Children {\n\n  private static final Pool<Builder> sBuildersPool = new SynchronizedPool<>(2);\n\n  private List<Section> mSections;\n\n  private Children() {\n    mSections = new ArrayList<>();\n  }\n\n  public static Builder METHOD_NAME() {\n    Builder builder = sBuildersPool.acquire();\n    if (builder == null) {\n      builder = new Builder();\n    }\n    builder.init(new Children());\n\n    return builder;\n  }\n\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public List<Section> getChildren() {\n    return mSections;\n  }\n\n  public static class Builder {\n\n    private Children mChildren;\n\n    private Builder() {}\n\n    private void init(Children children) {\n      mChildren = children;\n    }\n\n    public Builder child(@Nullable Section section) {\n      verifyValidState();\n\n      if (section != null) {\n        mChildren.mSections.add(section);\n      }\n\n      return this;\n    }\n\n    public Builder child(@Nullable List<Section> sectionList) {\n      verifyValidState();\n\n      if (sectionList == null || sectionList.isEmpty()) {\n        return this;\n      }\n\n      for (int i = 0; i < sectionList.size(); i++) {\n        Section section = sectionList.get(i);\n        if (section != null) {\n          mChildren.mSections.add(section);\n        }\n      }\n\n      return this;\n    }\n\n    public Builder child(@Nullable Section.Builder<?> sectionBuilder) {\n      verifyValidState();\n\n      if (sectionBuilder != null) {\n        mChildren.mSections.add(sectionBuilder.build());\n      }\n\n      return this;\n    }\n\n    public Builder children(@Nullable List<Section.Builder<?>> sectionBuilderList) {\n      verifyValidState();\n\n      if (sectionBuilderList == null || sectionBuilderList.isEmpty()) {\n        return this;\n      }\n\n      for (int i = 0; i < sectionBuilderList.size(); i++) {\n        Section.Builder<?> sectionBuilder = sectionBuilderList.get(i);\n        if (sectionBuilder != null) {\n          mChildren.mSections.add(sectionBuilder.build());\n        }\n      }\n\n      return this;\n    }\n\n    public Children build() {\n      verifyValidState();\n\n      Children children = mChildren;\n      mChildren = null;\n      sBuildersPool.release(this);\n\n      return children;\n    }\n\n    private void verifyValidState() {\n      if (mChildren == null) {\n        throw new IllegalStateException(\".build() call has been already made on this Builder.\");\n      }\n    }\n  }\n}\n"}
{"label": "offset", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport android.support.annotation.IntDef;\nimport android.support.annotation.Nullable;\nimport android.support.annotation.VisibleForTesting;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.sections.annotations.DiffSectionSpec;\nimport com.facebook.litho.widget.ComponentRenderInfo;\nimport com.facebook.litho.widget.RenderInfo;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A Change represent a single operation in a section's {@link ChangeSet}. A Change can be one of\n * Insert, Update or Delete. When creating a Change an index at which the Change will be applied has\n * to be specified. The index is local in the {@link DiffSectionSpec} coordinates. So to insert a\n * new item represented by a given Component in any give ChangeSetSpec at the top, a change would\n * have to be created with <code>\n * Change.insert(0, component);\n * </code>\n */\n@VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\npublic final class Change {\n\n  public static final int INSERT = 1; // INSERT(index, component)\n  public static final int INSERT_RANGE = -1; // INSERT_RANGE(index, count, [components])\n  public static final int UPDATE = 2; // UPDATE(index, component)\n  public static final int UPDATE_RANGE = -2; // UPDATE_RANGE(index, count, [components])\n  public static final int DELETE = 3; // DELETE(index)\n  public static final int DELETE_RANGE = -3; // DELETE_RANGE(index, count)\n  public static final int MOVE = 0; // MOVE(index, toIndex, component)\n\n  /** Describes how a {@link Section} count will change once the Change is applied. */\n  @IntDef({INSERT, UPDATE, DELETE, MOVE, INSERT_RANGE, UPDATE_RANGE, DELETE_RANGE})\n  @Retention(RetentionPolicy.SOURCE)\n  @interface Type {}\n\n  private static final List<RenderInfo> EMPTY = new ArrayList<>();\n\n  private @Type int mType;\n  private int mIndex;\n  private int mToIndex;\n  private int mCount;\n  private RenderInfo mRenderInfo;\n  private List<RenderInfo> mRenderInfos;\n\n  private Change(\n      @Type int ct,\n      int index,\n      int toIndex,\n      int count,\n      @Nullable RenderInfo renderInfo,\n      @Nullable List<RenderInfo> renderInfos) {\n    mType = ct;\n    mIndex = index;\n    mToIndex = toIndex;\n    mCount = count;\n    mRenderInfo = renderInfo == null ? ComponentRenderInfo.createEmpty() : renderInfo;\n    mRenderInfos =\n        renderInfos == null ? EMPTY : renderInfos;\n  }\n\n  /**\n   * @return a new Change with an index equal to its current index plus an offset. This is used\n   * internally by the framework when generating the final {@link ChangeSet} for the\n   * {@link com.facebook.litho.sections.SectionTree.Target}.\n   */\n  static Change METHOD_NAME(Change change, int METHOD_NAME) {\n    final int toIndex = change.mToIndex >= 0 ? change.mToIndex + METHOD_NAME : -1;\n    return acquire(\n        change.mType,\n        change.mIndex + METHOD_NAME,\n        toIndex,\n        change.mCount,\n        change.mRenderInfo,\n        change.mRenderInfos);\n  }\n\n  /**\n   * @return a new Change that is a copy of a given Change.\n   */\n  static Change copy(Change change) {\n    return acquire(\n        change.mType,\n        change.mIndex,\n        change.mToIndex,\n        change.mCount,\n        change.mRenderInfo,\n        change.mRenderInfos);\n  }\n\n  /**\n   * Creates a Change of type INSERT. As a result of this Change the {@link Component} c will be\n   * rendered at index in the context of the\n   * {@link DiffSectionSpec} creating this Change.\n   */\n  static Change insert(int index, RenderInfo renderInfo) {\n    return acquireSingularChange(INSERT, index, renderInfo);\n  }\n\n  /**\n   * Creates a Change of type INSERT_RANGE. As a result of this Change {@param count} number of\n   * components from {@param renderInfos} will be inserted starting at index {@param index}\n   * in the context of the {@link DiffSectionSpec} creating this Change.\n   */\n  static Change insertRange(int index, int count, List<RenderInfo> renderInfos) {\n    return acquireRangedChange(INSERT_RANGE, index, count, renderInfos);\n  }\n\n  /**\n   * Creates a Change of type UPDATE. As a result of this Change the {@link Component} c substitute\n   * the current Component rendered at index in the context of the\n   * {@link DiffSectionSpec} creating this Change.\n   */\n  static Change update(int index, RenderInfo renderInfo) {\n    return acquireSingularChange(UPDATE, index, renderInfo);\n  }\n\n  /**\n   * Creates a Change of type UPDATE_RANGE. As a result of this Change {@param count} number of\n   * components starting at {@param index} (in the context of the {@link DiffSectionSpec} creating\n   * this change) will be replaces by components from {@param renderInfos}.\n   */\n  static Change updateRange(int index, int count, List<RenderInfo> renderInfos) {\n    return acquireRangedChange(UPDATE_RANGE, index, count, renderInfos);\n  }\n\n  /**\n   * Creates a Change of type DELETE. As a result of this Change item at index in the context of the\n   * {@link DiffSectionSpec} creating this Change will be\n   * removed.\n   */\n  static Change remove(int index) {\n    return acquireSingularChange(DELETE, index, ComponentRenderInfo.createEmpty());\n  }\n\n  /**\n   * Creates a Change of type DELETE_RANGE. As a result of this Change {@param count} items\n   * starting at {@param index} in the context of the {@link DiffSectionSpec} creating this Change\n   * will be removed.\n   */\n  static Change removeRange(int index, int count) {\n    return acquireRangedChange(DELETE_RANGE, index, count, EMPTY);\n  }\n\n  /**\n   * Creates a Change of type MOVE. As a result of this Change item at fromIndex in the context of\n   * the {@link DiffSectionSpec} creating this Change will be moved to toIndex.\n   */\n  static Change move(int fromIndex, int toIndex) {\n    return acquireMoveChange(fromIndex, toIndex);\n  }\n\n  /** @return the type of this Change. */\n  @Type\n  public int getType() {\n    return mType;\n  }\n\n  /**\n   * @return the index at which this change will be applied.\n   */\n  int getIndex() {\n    return mIndex;\n  }\n\n  /**\n   * @return the index to which this change will move its item. This is only valid if type is MOVE.\n   */\n  int getToIndex() {\n    return mToIndex;\n  }\n\n  /**\n   * @return the number of changes to be made. This is only valid if type is *_RANGE.\n   */\n  public int getCount() {\n    return mCount;\n  }\n\n  /**\n   * @return the Component that will render this Change (if this Change is either an INSERT or an\n   *     UPDATE).\n   */\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public RenderInfo getRenderInfo() {\n    return mRenderInfo;\n  }\n\n  List<RenderInfo> getRenderInfos() {\n    return mRenderInfos;\n  }\n\n  //TODO t11953296\n  private static Change acquireMoveChange(\n      int index,\n      int toIndex) {\n    return acquire(MOVE, index, toIndex, 1, null, null);\n  }\n\n  //TODO t11953296\n  private static Change acquireSingularChange(\n      @Type int ct,\n      int index,\n      RenderInfo renderInfo) {\n    return acquire(ct, index, -1, 1, renderInfo, null);\n  }\n\n  //TODO t11953296\n  private static Change acquireRangedChange(\n      @Type int ct,\n      int index,\n      int count,\n      List<RenderInfo> renderInfos) {\n    return acquire(ct, index, -1, count, null, renderInfos);\n  }\n\n  //TODO t11953296\n  private static Change acquire(\n      @Type int ct,\n      int index,\n      int toIndex,\n      int count,\n      RenderInfo renderInfo,\n      List<RenderInfo> renderInfos) {\n    return new Change(ct, index, toIndex, count, renderInfo, renderInfos);\n  }\n\n  //TODO t11953296\n  void release() {\n    mRenderInfo = null;\n    mRenderInfos = null;\n  }\n}\n"}
{"label": "with|section|tree", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport static com.facebook.litho.sections.SectionLifecycle.StateUpdate;\n\nimport android.content.Context;\nimport android.support.annotation.Nullable;\nimport android.support.annotation.VisibleForTesting;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.EventHandler;\nimport com.facebook.litho.TreeProps;\nimport java.lang.ref.WeakReference;\n\npublic class SectionContext extends ComponentContext {\n\n  private SectionTree mSectionTree;\n  private WeakReference<Section> mScope;\n  private EventHandler<LoadingEvent> mTreeLoadingEventHandler;\n\n  public SectionContext(Context context) {\n    super(context);\n  }\n\n  public SectionContext(ComponentContext context) {\n    super(context.getBaseContext());\n  }\n\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public static SectionContext METHOD_NAME(SectionContext context, SectionTree sectionTree) {\n    SectionContext sectionContext = new SectionContext(context);\n    sectionContext.mSectionTree = sectionTree;\n    sectionContext.mTreeLoadingEventHandler = new SectionTreeLoadingEventHandler(sectionTree);\n\n    return sectionContext;\n  }\n\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public static SectionContext withScope(SectionContext context, Section scope) {\n    SectionContext sectionContext = new SectionContext(context);\n    sectionContext.mSectionTree = context.mSectionTree;\n    sectionContext.mTreeLoadingEventHandler = context.mTreeLoadingEventHandler;\n    sectionContext.mScope = new WeakReference<>(scope);\n\n    return sectionContext;\n  }\n\n  /**\n   * Notify the {@link SectionTree} that it needs to synchronously perform a state update.\n   *\n   * @param stateUpdate state update to perform\n   */\n  public void updateStateSync(StateUpdate stateUpdate) {\n    final Section section = mScope.get();\n    final SectionTree sectionTree = mSectionTree;\n    if (sectionTree == null || section == null) {\n      return;\n    }\n\n    sectionTree.updateState(section.getGlobalKey(), stateUpdate);\n  }\n\n  public void updateStateLazy(StateUpdate stateUpdate) {\n    final SectionTree sectionTree = mSectionTree;\n    final Section section = mScope.get();\n\n    sectionTree.updateStateLazy(section.getGlobalKey(), stateUpdate);\n  }\n\n  /**\n   * Notify the {@link SectionTree} that it needs to asynchronously perform a state update.\n   * @param stateUpdate state update to perform\n   */\n  public void updateStateAsync(StateUpdate stateUpdate) {\n    final Section section = mScope.get();\n    final SectionTree sectionTree = mSectionTree;\n    if (sectionTree == null || section == null) {\n      return;\n    }\n\n    sectionTree.updateStateAsync(section.getGlobalKey(), stateUpdate);\n  }\n\n  <E> EventHandler<E> newEventHandler(String name, int id, Object[] params) {\n    final Section section = mScope.get();\n    if (section == null) {\n      throw new IllegalStateException(\"Called newEventHandler on a released Section\");\n    }\n\n    return new EventHandler<E>(section, name, id, params);\n  }\n\n  public Section getSectionScope() {\n    final Section section = mScope.get();\n\n    return section;\n  }\n\n  @Nullable SectionTree getSectionTree() {\n    return mSectionTree;\n  }\n\n  EventHandler<LoadingEvent> getTreeLoadingEventHandler() {\n    return mTreeLoadingEventHandler;\n  }\n\n  @Override\n  protected void setTreeProps(TreeProps treeProps) {\n    super.setTreeProps(treeProps);\n  }\n\n  @Override\n  protected @Nullable TreeProps getTreeProps() {\n    return super.getTreeProps();\n  }\n}\n"}
{"label": "is|diff|section|spec", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport android.support.annotation.VisibleForTesting;\n\n/**\n * A utility elevating some of the visibility constraints internal classes, including {@link\n * SectionLifecycle}, {@link SectionContext} and {@link Section} to ease testing.\n */\n@VisibleForTesting\npublic final class SectionLifecycleTestUtil {\n  private SectionLifecycleTestUtil() {}\n\n  public static boolean METHOD_NAME(SectionLifecycle sectionLifecycle) {\n    return sectionLifecycle.METHOD_NAME();\n  }\n\n  public static Children createChildren(\n      SectionLifecycle sectionLifecycle, SectionContext c, Section component) {\n    return sectionLifecycle.createChildren(c);\n  }\n\n  public static void createInitialState(SectionLifecycle lifecycle, SectionContext c, Section s) {\n    lifecycle.createInitialState(c);\n  }\n\n  public static SectionLifecycle.StateContainer getStateContainer(Section section) {\n    return section.getStateContainer();\n  }\n\n  public static void setScopedContext(Section section, SectionContext c) {\n    section.setScopedContext(c);\n  }\n}\n"}
{"label": "request|focus", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport android.support.annotation.Nullable;\n\n/**\n * Pass this down as a {@link com.facebook.litho.annotations.Prop} and use it in your implementation\n * of {@link com.facebook.litho.sections.annotations.OnDataBound} to bind the focuser when you want to\n * trigger a requestFocus() from outside the Sections hierarchy.\n *\n * Example usage:\n *\n * class ExampleSectionSpec {\n *\n *  @OnDataBound\n *  void onDataBound(SectionContext c, @Prop RequestFocusAnnouncer<T> focusAnnouncer) {\n *    focusAnnouncer.setFocuser(new Focuser<T>() {\n *\n *      void requestFocus(T object) {\n *        int indexOfObject = findObjectInData(object);\n *        ExampleSection.requestFocus(c, indexOfObject);\n *      }\n *    });\n *  }\n * }\n */\npublic class RequestFocusAnnouncer<T> {\n\n  private @Nullable T mFocusObject;\n  private @Nullable Focuser mFocuser;\n\n  public interface Focuser<T> {\n    void METHOD_NAME(T focusObject);\n  }\n\n  public void METHOD_NAME(T focusObject) {\n    mFocusObject = focusObject;\n\n    if (mFocuser != null && focusObject != null) {\n      mFocuser.METHOD_NAME(focusObject);\n      mFocusObject = null;\n    }\n  }\n\n  public void setFocuser(Focuser focuser) {\n    if (focuser == null) {\n      return;\n    }\n\n    mFocuser = focuser;\n    if (mFocusObject != null) {\n      METHOD_NAME(mFocusObject);\n    }\n  }\n}\n"}
{"label": "get|change|at", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections;\n\nimport static com.facebook.litho.sections.Change.DELETE;\nimport static com.facebook.litho.sections.Change.DELETE_RANGE;\nimport static com.facebook.litho.sections.Change.INSERT;\nimport static com.facebook.litho.sections.Change.INSERT_RANGE;\nimport static com.facebook.litho.sections.Change.MOVE;\nimport static com.facebook.litho.sections.Change.UPDATE;\nimport static com.facebook.litho.sections.Change.UPDATE_RANGE;\n\nimport android.support.annotation.VisibleForTesting;\nimport com.facebook.litho.sections.SectionTree.Target;\nimport com.facebook.litho.sections.annotations.DiffSectionSpec;\nimport com.facebook.litho.sections.annotations.OnDiff;\nimport com.facebook.litho.widget.RenderInfo;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A ChangeSet represent a list of Change that has to be applied to a\n * {@link Target} as the result of an update of a\n * {@link Section}. A ChangeSet is provided in the\n * {@link OnDiff} of a\n * {@link DiffSectionSpec} to allow the ChangeSetSpec to\n * define its changes based on old/new props and state.\n */\npublic final class ChangeSet {\n\n  private final List<Change> mChanges;\n  private int mFinalCount;\n\n  private ChangeSet() {\n    mChanges = new ArrayList<>();\n    mFinalCount = 0;\n  }\n\n  /**\n   * @return the {@link Change} at index.\n   */\n  public Change METHOD_NAME(int index) {\n    return mChanges.get(index);\n  }\n\n  /**\n   * @return the number of {@link Change}s in this ChangeSet.\n   */\n  public int getChangeCount() {\n    return mChanges.size();\n  }\n\n  /**\n   * Add a new Change to this ChangeSet. This is what a {@link DiffSectionSpec} would call in its\n   * {@link OnDiff} method to append a {@link Change}.\n   */\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public void addChange(Change change) {\n    int changeDelta = 0;\n    switch (change.getType()) {\n      case INSERT:\n        changeDelta = 1;\n        break;\n      case INSERT_RANGE:\n        changeDelta = change.getCount();\n        break;\n      case DELETE:\n        changeDelta = -1;\n        break;\n      case DELETE_RANGE:\n        changeDelta = -change.getCount();\n        break;\n      case UPDATE:\n      case UPDATE_RANGE:\n      case MOVE:\n      default:\n        break;\n    }\n\n    mFinalCount += changeDelta;\n    mChanges.add(change);\n  }\n\n  public void insert(int index, RenderInfo renderInfo) {\n    addChange(Change.insert(index, renderInfo));\n  }\n\n  public void insertRange(int index, int count, List<RenderInfo> renderInfos) {\n    addChange(Change.insertRange(index, count, renderInfos));\n  }\n\n  public void update(int index, RenderInfo renderInfo) {\n    addChange(Change.update(index, renderInfo));\n  }\n\n  public void updateRange(int index, int count, List<RenderInfo> renderInfos) {\n    addChange(Change.updateRange(index, count, renderInfos));\n  }\n\n  public void delete(int index) {\n    addChange(Change.remove(index));\n  }\n\n  public void deleteRange(int index, int count) {\n    addChange(Change.removeRange(index, count));\n  }\n\n  public void move(int fromIndex, int toIndex) {\n    addChange(Change.move(fromIndex, toIndex));\n  }\n\n  /**\n   * @return the total number of items in the {@link Target}\n   * after this ChangeSet will be applied.\n   */\n  int getCount() {\n    return mFinalCount;\n  }\n\n  /** @return an empty ChangeSet. */\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public static ChangeSet acquireChangeSet() {\n    return acquireChangeSet(0);\n  }\n\n  /**\n   * @return an empty ChangeSet starting from count startCount.\n   */\n  static ChangeSet acquireChangeSet(int startCount) {\n    final ChangeSet changeSet = acquire();\n    changeSet.mFinalCount = startCount;\n\n    return changeSet;\n  }\n\n  /**\n   * Used internally by the framework to merge all the ChangeSet generated by all the leaf {@link\n   * Section}. The merged ChangeSet will be passed to the {@link Target}.\n   */\n  static ChangeSet merge(ChangeSet first, ChangeSet second) {\n    final ChangeSet mergedChangeSet = acquireChangeSet();\n    final int firstCount = first != null ? first.mFinalCount : 0;\n    final int secondCount = second != null ? second.mFinalCount : 0;\n\n    List<Change> mergedChanged =mergedChangeSet.mChanges;\n\n    if (first != null) {\n      for (Change change : first.mChanges) {\n        mergedChanged.add(Change.copy(change));\n      }\n    }\n\n    if (second != null) {\n      for (Change change : second.mChanges) {\n        mergedChanged.add(Change.offset(change, firstCount));\n      }\n    }\n\n    mergedChangeSet.mFinalCount = firstCount + secondCount;\n\n    return mergedChangeSet;\n  }\n\n  //TODO implement pools t11953296\n  private static ChangeSet acquire() {\n    return new ChangeSet();\n  }\n\n  //TODO implement pools t11953296\n  void release() {\n    for (Change change : mChanges) {\n      change.release();\n    }\n\n    mChanges.clear();\n    mFinalCount = 0;\n  }\n}\n"}
{"label": "on|create|initial|state", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.common;\n\nimport android.graphics.drawable.ColorDrawable;\nimport com.facebook.litho.ClickEvent;\nimport com.facebook.litho.StateValue;\nimport com.facebook.litho.annotations.METHOD_NAME;\nimport com.facebook.litho.annotations.OnEvent;\nimport com.facebook.litho.annotations.OnUpdateState;\nimport com.facebook.litho.annotations.Param;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.State;\nimport com.facebook.litho.sections.Children;\nimport com.facebook.litho.sections.SectionContext;\nimport com.facebook.litho.sections.annotations.GroupSectionSpec;\nimport com.facebook.litho.sections.annotations.OnCreateChildren;\nimport com.facebook.litho.sections.annotations.OnDataBound;\nimport com.facebook.litho.widget.Image;\nimport com.facebook.litho.widget.Text;\n\n/**\n * Dummy {@link GroupSectionSpec} to illustrate how to test sections.\n */\n@GroupSectionSpec\npublic class VerySimpleGroupSectionSpec {\n\n  @METHOD_NAME\n  protected static void METHOD_NAME(\n      SectionContext c,\n      StateValue<Integer> extra) {\n    extra.set(0);\n  }\n\n  @OnCreateChildren\n  protected static Children onCreateChildren(\n      SectionContext c, @State(canUpdateLazily = true) int extra, @Prop int numberOfDummy) {\n    Children.Builder builder = Children.create();\n\n    if (extra > 0) {\n      builder.child(SingleComponentSection.create(c)\n          .component(Image.create(c).drawable(new ColorDrawable()).build()));\n    }\n\n    for (int i = 0; i < numberOfDummy+extra; i++) {\n      builder.child(SingleComponentSection.create(c)\n          .component(Text.create(c).text(\"Lol hi \" + i).build())\n          .key(\"key\" + i)\n          .build());\n    }\n    return builder.build();\n  }\n\n  @OnDataBound\n  static void onDataBound(\n      SectionContext c, @Prop int numberOfDummy, @State(canUpdateLazily = true) int extra) {\n    VerySimpleGroupSection.lazyUpdateExtra(c, extra - numberOfDummy);\n  }\n\n  @OnUpdateState\n  static void onUpdateState(\n      StateValue<Integer> extra,\n      @Param int newExtra) {\n    extra.set(newExtra);\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void onImageClick(SectionContext c) {\n    VerySimpleGroupSection.onUpdateState(c, 3);\n  }\n}\n"}
{"label": "on|create|layout", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.annotations.LayoutSpec;\nimport com.facebook.litho.annotations.METHOD_NAME;\n\n@LayoutSpec\npublic class SimpleLayoutSpec {\n  @METHOD_NAME\n  static ComponentLayout METHOD_NAME(\n      ComponentContext context) {\n    return null;\n  }\n}\n"}
{"label": "get|value", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\npublic class TestTreeProp {\n\n  final private long mValue;\n\n  public TestTreeProp(long value) {\n    mValue = value;\n  }\n\n  public long METHOD_NAME() {\n    return mValue;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n      return false;\n    }\n    TestTreeProp other = (TestTreeProp) obj;\n    return other.METHOD_NAME() == mValue;\n  }\n\n  @Override\n  public int hashCode() {\n    return (int) mValue;\n  }\n}\n"}
{"label": "create", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\npackage com.facebook.litho.processor.integration.resources;\n\nimport android.support.v4.util.Pools;\nimport com.facebook.litho.ActualComponentLayout;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLifecycle;\nimport com.facebook.litho.LithoView;\nimport com.facebook.litho.Size;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.ResType;\nimport java.util.BitSet;\n\n/**\n * @prop-required content com.facebook.litho.Component\n * @prop-required ratio double\n * @see com.facebook.litho.processor.integration.resources.SimpleMountSpec\n */\npublic final class SimpleMount extends Component {\n  private static final Pools.SynchronizedPool<Builder> sBuilderPool = new Pools.SynchronizedPool<Builder>(2);\n\n  @Prop(resType = ResType.NONE, optional = false)\n  Component content;\n\n  @Prop(resType = ResType.NONE, optional = false)\n  double ratio;\n\n  private SimpleMount() {\n    super();\n  }\n\n  @Override\n  public String getSimpleName() {\n    return \"SimpleMount\";\n  }\n\n  @Override\n  public boolean isEquivalentTo(Component other) {\n    if (this == other) {\n      return true;\n    }\n    if (other == null || getClass() != other.getClass()) {\n      return false;\n    }\n    SimpleMount simpleMountRef = (SimpleMount) other;\n    if (this.getId() == simpleMountRef.getId()) {\n      return true;\n    }\n    if (content != null\n        ? !content.isEquivalentTo(simpleMountRef.content)\n        : simpleMountRef.content != null) {\n      return false;\n    }\n    if (Double.compare(ratio, simpleMountRef.ratio) != 0) {\n      return false;\n    }\n    return true;\n  }\n\n  @Override\n  public SimpleMount makeShallowCopy() {\n    SimpleMount component = (SimpleMount) super.makeShallowCopy();\n    component.content = component.content != null ? component.content.makeShallowCopy() : null;\n    return component;\n  }\n\n  @Override\n  protected void onMeasure(\n      ComponentContext c,\n      ActualComponentLayout layout,\n      int widthSpec,\n      int heightSpec,\n      Size size) {\n    SimpleMountSpec.onMeasure(\n        (ComponentContext) c,\n        (ActualComponentLayout) layout,\n        (int) widthSpec,\n        (int) heightSpec,\n        (Size) size,\n        (double) ratio);\n  }\n\n  @Override\n  protected boolean canMeasure() {\n    return true;\n  }\n\n  @Override\n  protected Object onCreateMountContent(ComponentContext c) {\n    Object _result = (Object) SimpleMountSpec.onCreateMountContent(\n        (ComponentContext) c);\n    return _result;\n  }\n\n  @Override\n  protected void onMount(ComponentContext c, Object lithoView) {\n    SimpleMountSpec.onMount((ComponentContext) c, (LithoView) lithoView, (Component) content);\n  }\n\n  @Override\n  protected void onUnmount(ComponentContext c, Object mountedView) {\n    SimpleMountSpec.onUnmount(\n        (ComponentContext) c,\n        (LithoView) mountedView);\n  }\n\n  @Override\n  public ComponentLifecycle.MountType getMountType() {\n    return ComponentLifecycle.MountType.VIEW;\n  }\n\n  @Override\n  protected int poolSize() {\n    return 3;\n  }\n\n  @Override\n  protected boolean canPreallocate() {\n    return false;\n  }\n\n  public static Builder METHOD_NAME(ComponentContext context) {\n    return METHOD_NAME(context, 0, 0);\n  }\n\n  public static Builder METHOD_NAME(ComponentContext context, int defStyleAttr, int defStyleRes) {\n    Builder builder = sBuilderPool.acquire();\n    if (builder == null) {\n      builder = new Builder();\n    }\n    SimpleMount instance = new SimpleMount();\n    builder.init(context, defStyleAttr, defStyleRes, instance);\n    return builder;\n  }\n\n  public static class Builder extends Component.Builder<Builder> {\n    private static final String[] REQUIRED_PROPS_NAMES = new String[] {\"content\", \"ratio\"};\n\n    private static final int REQUIRED_PROPS_COUNT = 2;\n\n    SimpleMount mSimpleMount;\n\n    ComponentContext mContext;\n\n    private BitSet mRequired = new BitSet(REQUIRED_PROPS_COUNT);\n\n    private void init(ComponentContext context, int defStyleAttr, int defStyleRes,\n        SimpleMount simpleMountRef) {\n      super.init(context, defStyleAttr, defStyleRes, simpleMountRef);\n      mSimpleMount = simpleMountRef;\n      mContext = context;\n      mRequired.clear();\n    }\n\n    public Builder content(Component content) {\n      this.mSimpleMount.content = content == null ? null : content.makeShallowCopy();\n      mRequired.set(0);\n      return this;\n    }\n\n    public Builder content(Component.Builder<?> contentBuilder) {\n      this.mSimpleMount.content = contentBuilder.build();\n      mRequired.set(0);\n      return this;\n    }\n\n    public Builder ratio(double ratio) {\n      this.mSimpleMount.ratio = ratio;\n      mRequired.set(1);\n      return this;\n    }\n\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n\n    @Override\n    public SimpleMount build() {\n      checkArgs(REQUIRED_PROPS_COUNT, mRequired, REQUIRED_PROPS_NAMES);\n      SimpleMount simpleMountRef = mSimpleMount;\n      release();\n      return simpleMountRef;\n    }\n\n    @Override\n    protected void release() {\n      super.release();\n      mSimpleMount = null;\n      mContext = null;\n      sBuilderPool.release(this);\n    }\n  }\n}\n\n\n"}
{"label": "on|create|layout", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.annotations.LayoutSpec;\nimport com.facebook.litho.annotations.METHOD_NAME;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.ResType;\n\n@LayoutSpec\npublic class BasicLayoutSpec {\n  @METHOD_NAME\n  static ComponentLayout METHOD_NAME(\n      ComponentContext context,\n      @Prop String myStringProp,\n      @Prop(resType = ResType.COLOR) int myRequiredColorProp,\n      @Prop(resType = ResType.DIMEN_SIZE) float myDimenSizeProp,\n      @Prop Component child) {\n    return null;\n  }\n}\n"}
{"label": "create", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.processor.integration.resources;\n\nimport android.support.v4.util.Pools;\nimport com.facebook.litho.EventHandler;\nimport com.facebook.litho.sections.ChangeSet;\nimport com.facebook.litho.sections.LoadingEvent;\nimport com.facebook.litho.sections.Section;\nimport com.facebook.litho.sections.SectionContext;\n\npublic final class SimpleDiffSection extends Section {\n  private static final Pools.SynchronizedPool<Builder> sBuilderPool =\n      new Pools.SynchronizedPool<Builder>(2);\n\n  private SimpleDiffSection() {\n    super();\n  }\n\n  @Override\n  public String getSimpleName() {\n    return \"SimpleDiffSection\";\n  }\n\n  @Override\n  public boolean isEquivalentTo(Section other) {\n    if (this == other) {\n      return true;\n    }\n    if (other == null || getClass() != other.getClass()) {\n      return false;\n    }\n    SimpleDiffSection simpleDiffSectionRef = (SimpleDiffSection) other;\n    return true;\n  }\n\n  public static Builder METHOD_NAME(SectionContext context) {\n    Builder builder = sBuilderPool.acquire();\n    if (builder == null) {\n      builder = new Builder();\n    }\n    SimpleDiffSection instance = new SimpleDiffSection();\n    builder.init(context, instance);\n    return builder;\n  }\n\n  @Override\n  protected void generateChangeSet(\n      SectionContext c, ChangeSet changeSet, Section _prevAbstractImpl, Section _nextAbstractImpl) {\n    SimpleDiffSection _prevImpl = (SimpleDiffSection) _prevAbstractImpl;\n    SimpleDiffSection _nextImpl = (SimpleDiffSection) _nextAbstractImpl;\n    SimpleDiffSectionSpec.onCreateChangeset((SectionContext) c, (ChangeSet) changeSet);\n  }\n\n  @Override\n  protected boolean isDiffSectionSpec() {\n    return true;\n  }\n\n  public static class Builder extends Section.Builder<Builder> {\n    SimpleDiffSection mSimpleDiffSection;\n\n    SectionContext mContext;\n\n    private void init(SectionContext context, SimpleDiffSection simpleDiffSectionRef) {\n      super.init(context, simpleDiffSectionRef);\n      mSimpleDiffSection = simpleDiffSectionRef;\n      mContext = context;\n    }\n\n    @Override\n    public Builder key(String key) {\n      return super.key(key);\n    }\n\n    @Override\n    public Builder loadingEventHandler(EventHandler<LoadingEvent> loadingEventHandler) {\n      return super.loadingEventHandler(loadingEventHandler);\n    }\n\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n\n    @Override\n    public SimpleDiffSection build() {\n      SimpleDiffSection simpleDiffSectionRef = mSimpleDiffSection;\n      release();\n      return simpleDiffSectionRef;\n    }\n\n    @Override\n    protected void release() {\n      super.release();\n      mSimpleDiffSection = null;\n      mContext = null;\n      sBuilderPool.release(this);\n    }\n  }\n}\n"}
{"label": "create", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.processor.integration.resources;\n\nimport android.support.v4.util.Pools;\nimport com.facebook.litho.EventHandler;\nimport com.facebook.litho.sections.Children;\nimport com.facebook.litho.sections.LoadingEvent;\nimport com.facebook.litho.sections.Section;\nimport com.facebook.litho.sections.SectionContext;\n\npublic final class SimpleGroupSection extends Section {\n  private static final Pools.SynchronizedPool<Builder> sBuilderPool =\n      new Pools.SynchronizedPool<Builder>(2);\n\n  private SimpleGroupSection() {\n    super();\n  }\n\n  @Override\n  public String getSimpleName() {\n    return \"SimpleGroupSection\";\n  }\n\n  @Override\n  public boolean isEquivalentTo(Section other) {\n    if (this == other) {\n      return true;\n    }\n    if (other == null || getClass() != other.getClass()) {\n      return false;\n    }\n    SimpleGroupSection simpleGroupSectionRef = (SimpleGroupSection) other;\n    return true;\n  }\n\n  public static Builder METHOD_NAME(SectionContext context) {\n    Builder builder = sBuilderPool.acquire();\n    if (builder == null) {\n      builder = new Builder();\n    }\n    SimpleGroupSection instance = new SimpleGroupSection();\n    builder.init(context, instance);\n    return builder;\n  }\n\n  @Override\n  protected Children createChildren(SectionContext c) {\n    Children _result = (Children) SimpleGroupSectionSpec.onCreateChildren((SectionContext) c);\n    return _result;\n  }\n\n  public static class Builder extends Section.Builder<Builder> {\n    SimpleGroupSection mSimpleGroupSection;\n\n    SectionContext mContext;\n\n    private void init(SectionContext context, SimpleGroupSection simpleGroupSectionRef) {\n      super.init(context, simpleGroupSectionRef);\n      mSimpleGroupSection = simpleGroupSectionRef;\n      mContext = context;\n    }\n\n    @Override\n    public Builder key(String key) {\n      return super.key(key);\n    }\n\n    @Override\n    public Builder loadingEventHandler(EventHandler<LoadingEvent> loadingEventHandler) {\n      return super.loadingEventHandler(loadingEventHandler);\n    }\n\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n\n    @Override\n    public SimpleGroupSection build() {\n      SimpleGroupSection simpleGroupSectionRef = mSimpleGroupSection;\n      release();\n      return simpleGroupSectionRef;\n    }\n\n    @Override\n    protected void release() {\n      super.release();\n      mSimpleGroupSection = null;\n      mContext = null;\n      sBuilderPool.release(this);\n    }\n  }\n}\n"}
{"label": "on|create|children", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.processor.integration.resources;\n\nimport com.facebook.litho.sections.Children;\nimport com.facebook.litho.sections.SectionContext;\nimport com.facebook.litho.sections.annotations.GroupSectionSpec;\nimport com.facebook.litho.sections.annotations.METHOD_NAME;\n\n@GroupSectionSpec\npublic class SimpleGroupSectionSpec {\n\n  @METHOD_NAME\n  protected static Children METHOD_NAME(SectionContext c) {\n    return null;\n  }\n}\n"}
{"label": "on|create|tree|prop", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.processor.integration.resources;\n\nimport android.view.View;\nimport android.widget.TextView;\nimport com.facebook.litho.ClickEvent;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.Diff;\nimport com.facebook.litho.StateValue;\nimport com.facebook.litho.annotations.FromEvent;\nimport com.facebook.litho.annotations.OnCreateInitialState;\nimport com.facebook.litho.annotations.METHOD_NAME;\nimport com.facebook.litho.annotations.OnEvent;\nimport com.facebook.litho.annotations.OnUpdateState;\nimport com.facebook.litho.annotations.Param;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.ResType;\nimport com.facebook.litho.annotations.ShouldUpdate;\nimport com.facebook.litho.annotations.State;\nimport com.facebook.litho.annotations.TreeProp;\nimport com.facebook.litho.sections.Children;\nimport com.facebook.litho.sections.SectionContext;\nimport com.facebook.litho.sections.annotations.GroupSectionSpec;\nimport com.facebook.litho.sections.annotations.OnBindService;\nimport com.facebook.litho.sections.annotations.OnCreateChildren;\nimport com.facebook.litho.sections.annotations.OnCreateService;\nimport com.facebook.litho.sections.annotations.OnDataBound;\nimport com.facebook.litho.sections.annotations.OnRefresh;\nimport com.facebook.litho.sections.annotations.OnUnbindService;\nimport com.facebook.litho.sections.annotations.OnViewportChanged;\n\n/** Comment to be copied in generated section */\n@GroupSectionSpec(events = TestEvent.class, isPublic = false)\npublic class FullGroupSectionSpec<T> {\n\n  static class TreePropWrapper {}\n\n  @OnCreateInitialState\n  static <T> void onCreateInitialState(\n      SectionContext c,\n      @Prop int prop1,\n      StateValue<T> state1,\n      StateValue<Object> state2) {}\n\n  @METHOD_NAME\n  static TreePropWrapper METHOD_NAME(SectionContext c, @TreeProp TreePropWrapper treeProp) {\n    return new TreePropWrapper();\n  }\n\n  @OnCreateService\n  static String onCreateService(\n      SectionContext c,\n      @Prop(optional = true) String prop2) {\n    return prop2;\n  }\n\n  @OnCreateChildren\n  protected static <T> Children onCreateChildren(\n      SectionContext c,\n      @Prop Component prop3,\n      @Prop(resType = ResType.STRING) String prop4,\n      @State T state1) {\n    return null;\n  }\n\n  @OnUpdateState\n  protected static void updateState(StateValue<Object> state2, @Param Object param) {}\n\n  @OnBindService\n  static void bindService(\n      SectionContext c,\n      String service,\n      @Prop int prop1,\n      @State(canUpdateLazily = true) Object state2) {\n\n  }\n\n  @OnUnbindService\n  static void unbindService(\n      SectionContext c,\n      String service,\n      @Prop int prop1,\n      @State(canUpdateLazily = true) Object state2) {\n\n  }\n\n  @OnRefresh\n  static void onRefresh(\n      SectionContext c,\n      String service,\n      @Prop(optional = true) String prop2) {\n\n  }\n\n  @OnDataBound\n  static void onDataBound(\n      SectionContext c,\n      @Prop Component prop3,\n      @State(canUpdateLazily = true) Object state2) {\n\n  }\n\n  @ShouldUpdate\n  static boolean shouldUpdate(@Prop Diff<Integer> prop1) {\n    return true;\n  }\n\n  @OnViewportChanged\n  static <T> void onViewportChanged(\n      SectionContext c,\n      int firstVisibleIndex,\n      int lastVisibleIndex,\n      int totalCount,\n      int firstFullyVisibleIndex,\n      int lastFullyVisibleIndex,\n      @State T state1,\n      @State(canUpdateLazily = true) Object state2,\n      @Prop int prop1,\n      @Prop(optional = true) String prop2,\n      @Prop Component prop3) {\n\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void testEvent(\n      SectionContext c,\n      @FromEvent(baseClass = View.class) TextView view,\n      @Param int someParam,\n      @State(canUpdateLazily = true) Object state2,\n      @Prop(optional = true) String prop2) {}\n}\n"}
{"label": "on|create|service", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.sections.processor.integration.resources;\n\nimport android.view.View;\nimport com.facebook.litho.ClickEvent;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.Diff;\nimport com.facebook.litho.StateValue;\nimport com.facebook.litho.annotations.FromEvent;\nimport com.facebook.litho.annotations.OnCreateInitialState;\nimport com.facebook.litho.annotations.OnEvent;\nimport com.facebook.litho.annotations.OnUpdateState;\nimport com.facebook.litho.annotations.Param;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.ShouldUpdate;\nimport com.facebook.litho.annotations.State;\nimport com.facebook.litho.sections.ChangeSet;\nimport com.facebook.litho.sections.SectionContext;\nimport com.facebook.litho.sections.annotations.DiffSectionSpec;\nimport com.facebook.litho.sections.annotations.OnBindService;\nimport com.facebook.litho.sections.annotations.METHOD_NAME;\nimport com.facebook.litho.sections.annotations.OnDataBound;\nimport com.facebook.litho.sections.annotations.OnDiff;\nimport com.facebook.litho.sections.annotations.OnRefresh;\nimport com.facebook.litho.sections.annotations.OnUnbindService;\nimport com.facebook.litho.sections.annotations.OnViewportChanged;\nimport java.util.List;\n\n@DiffSectionSpec(events = TestEvent.class)\npublic class FullDiffSectionSpec<T> {\n\n  @OnCreateInitialState\n  static void onCreateInitialState(\n      SectionContext c,\n      @Prop Integer prop1,\n      StateValue<Object> state1) {}\n\n  @OnDiff\n  protected static <T> void onDiff(\n      SectionContext c,\n      ChangeSet changeSet,\n      @Prop Diff<List<T>> data,\n      @Prop Diff<Component> prop3,\n      @State Diff<Object> state1) {}\n\n  @OnUpdateState\n  protected static void updateState(StateValue<Object> state1, @Param Object param) {}\n\n  @METHOD_NAME\n  static String METHOD_NAME(\n      SectionContext c,\n      @Prop(optional = true) String prop2) {\n    return prop2;\n  }\n\n  @OnBindService\n  static void bindService(\n      SectionContext c,\n      String service) {\n\n  }\n\n  @OnUnbindService\n  static void unbindService(\n      SectionContext c,\n      String service) {\n\n  }\n\n  @OnRefresh\n  static void onRefresh(\n      SectionContext c,\n      String service) {\n\n  }\n\n  @OnDataBound\n  static void onDataBound(\n      SectionContext c) {\n\n  }\n\n  @ShouldUpdate\n  static boolean shouldUpdate(@Prop Diff<Integer> prop1) {\n    return true;\n  }\n\n  @OnViewportChanged\n  static void onViewportChanged(\n      SectionContext c,\n      int firstVisibleIndex,\n      int lastVisibleIndex,\n      int totalCount,\n      int firstFullyVisibleIndex,\n      int lastFullyVisibleIndex) {\n\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void testEvent(SectionContext c, @FromEvent View view, @Param int someParam) {}\n}\n"}
{"label": "matcher", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ResourceResolver;\nimport com.facebook.litho.testing.assertj.ComponentMatcher;\nimport com.facebook.litho.testing.subcomponents.InspectableComponent;\nimport org.assertj.core.description.TextDescription;\n\n/**\n *\n * @see com.facebook.litho.processor.integration.resources.SimpleTestSampleSpec\n */\npublic final class SimpleTestSample implements SimpleTestSampleSpec {\n  public static Matcher METHOD_NAME(ComponentContext c) {\n    return new Matcher(c);\n  }\n\n  public static class METHOD_NAME extends ResourceResolver {\n    METHOD_NAME(ComponentContext c) {\n      super.init(c, c.getResourceCache());\n    }\n\n    public ComponentMatcher build() {\n      return new ComponentMatcher() {\n        @Override\n        public boolean matches(InspectableComponent value) {\n          if (!value.getComponentClass().isAssignableFrom(com.facebook.litho.processor.integration.resources.SimpleLayout.class)) {\n            as(new TextDescription(\"Sub-component of type \\\"com.facebook.litho.processor.integration.resources.SimpleLayout\\\"\"));\n            return false;\n          }\n          final com.facebook.litho.processor.integration.resources.SimpleLayout impl = (com.facebook.litho.processor.integration.resources.SimpleLayout) value.getComponent();\n          return true;\n        }\n      };\n    }\n  }\n}\n"}
{"label": "on|create|mount|content", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\nimport com.facebook.litho.ActualComponentLayout;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentTree;\nimport com.facebook.litho.LithoView;\nimport com.facebook.litho.Size;\nimport com.facebook.litho.annotations.MountSpec;\nimport com.facebook.litho.annotations.METHOD_NAME;\nimport com.facebook.litho.annotations.OnMeasure;\nimport com.facebook.litho.annotations.OnMount;\nimport com.facebook.litho.annotations.OnUnmount;\nimport com.facebook.litho.annotations.Prop;\n\n@MountSpec\nclass SimpleMountSpec {\n\n  @OnMeasure\n  static void onMeasure(\n      ComponentContext c,\n      ActualComponentLayout layout,\n      int widthSpec,\n      int heightSpec,\n      Size size,\n      @Prop double ratio) {}\n\n  @METHOD_NAME\n  static LithoView METHOD_NAME(ComponentContext c) {\n    return new LithoView(c);\n  }\n\n  @OnMount\n  static void onMount(ComponentContext c, LithoView lithoView, @Prop Component content) {\n    lithoView.setComponentTree(\n        ComponentTree.create(c, content).incrementalMount(false).layoutDiffing(false).build());\n  }\n\n  @OnUnmount\n  static void onUnmount(\n      ComponentContext c,\n      LithoView mountedView) {\n    mountedView.setComponentTree(null);\n  }\n}\n\n"}
{"label": "on|create|layout", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\nimport android.content.Context;\n\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.annotations.LayoutSpec;\nimport com.facebook.litho.annotations.METHOD_NAME;\n\n@LayoutSpec\npublic class IncorrectOnCreateLayoutArgsComponentSpec {\n  @METHOD_NAME\n  static ComponentLayout METHOD_NAME(\n      Context context /* error: Expected com.facebook.litho.ComponentContext */) {\n    return null;\n  }\n}\n"}
{"label": "on|create|feed|prefetcher|prop", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.processor.integration.resources;\n\nimport android.annotation.TargetApi;\nimport android.os.Build;\nimport android.view.View;\nimport com.facebook.litho.ClickEvent;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.Diff;\nimport com.facebook.litho.Output;\nimport com.facebook.litho.StateValue;\nimport com.facebook.litho.Transition;\nimport com.facebook.litho.annotations.FromEvent;\nimport com.facebook.litho.annotations.FromTrigger;\nimport com.facebook.litho.annotations.LayoutSpec;\nimport com.facebook.litho.annotations.OnCreateInitialState;\nimport com.facebook.litho.annotations.OnCreateLayout;\nimport com.facebook.litho.annotations.OnCreateTransition;\nimport com.facebook.litho.annotations.OnCreateTreeProp;\nimport com.facebook.litho.annotations.OnEvent;\nimport com.facebook.litho.annotations.OnLoadStyle;\nimport com.facebook.litho.annotations.OnTrigger;\nimport com.facebook.litho.annotations.OnUpdateState;\nimport com.facebook.litho.annotations.Param;\nimport com.facebook.litho.annotations.Prop;\nimport com.facebook.litho.annotations.PropDefault;\nimport com.facebook.litho.annotations.State;\nimport com.facebook.litho.annotations.TreeProp;\n\n@LayoutSpec(events = TestEvent.class)\n@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)\npublic class TestLayoutSpec<S extends View> {\n  @PropDefault protected static final boolean prop2 = true;\n\n  @OnLoadStyle\n  static void onLoadStyle(\n      ComponentContext c,\n      Output<Boolean> prop2,\n      Output<Object> prop3) {\n  }\n\n  @OnCreateInitialState\n  static <S extends View> void createInitialState(\n      ComponentContext c,\n      @Prop int prop1,\n      StateValue<S> state2) {\n  }\n\n  @OnCreateTreeProp\n  static TestTreeProp METHOD_NAME(\n      ComponentContext c,\n      @Prop long prop6) {\n    return new TestTreeProp(prop6);\n  }\n\n  @OnCreateLayout\n  static <S extends View> ComponentLayout onCreateLayout(\n      ComponentContext context,\n      @Prop(optional = true) boolean prop2,\n      @Prop Object prop3,\n      @Prop char[] prop4,\n      @State(canUpdateLazily = true) long state1,\n      @State S state2,\n      @State int state3,\n      @TreeProp TestTreeProp treeProp,\n      @Prop Component child) {\n    return null;\n  }\n\n  @OnEvent(ClickEvent.class)\n  static void testLayoutEvent(\n      ComponentContext c,\n      @FromEvent View view,\n      @Param int param1,\n      @Prop Object prop3,\n      @Prop char prop5,\n      @State(canUpdateLazily = true) long state1) {\n  }\n\n  @OnTrigger(ClickEvent.class)\n  static void onClickEventTrigger(ComponentContext c, @FromTrigger View view) {}\n\n  @OnUpdateState\n  static void updateCurrentState(\n      StateValue<Long> state1,\n      @Param int someParam) {\n  }\n\n  @OnCreateTransition\n  static Transition onCreateTransition(\n      ComponentContext c,\n      @Prop Object prop3,\n      @State(canUpdateLazily = true) long state1,\n      @State Diff<Integer> state3) {\n    return Transition.parallel(\n      Transition.create(\"testKey\"));\n  }\n}\n"}
{"label": "create", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\npackage com.facebook.litho.processor.integration.resources;\n\nimport android.support.v4.util.Pools;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\n\npublic final class SimpleLayout extends Component {\n  private static final Pools.SynchronizedPool<Builder> sBuilderPool = new Pools.SynchronizedPool<Builder>(2);\n\n  private SimpleLayout() {\n    super();\n  }\n\n  @Override\n  public String getSimpleName() {\n    return \"SimpleLayout\";\n  }\n\n  @Override\n  public boolean isEquivalentTo(Component other) {\n    if (this == other) {\n      return true;\n    }\n    if (other == null || getClass() != other.getClass()) {\n      return false;\n    }\n    SimpleLayout simpleLayoutRef = (SimpleLayout) other;\n    if (this.getId() == simpleLayoutRef.getId()) {\n      return true;\n    }\n    return true;\n  }\n\n  @Override\n  protected ComponentLayout onCreateLayout(ComponentContext context) {\n    ComponentLayout _result = (ComponentLayout) SimpleLayoutSpec.onCreateLayout(\n        (ComponentContext) context);\n    return _result;\n  }\n\n  public static Builder METHOD_NAME(ComponentContext context) {\n    return METHOD_NAME(context, 0, 0);\n  }\n\n  public static Builder METHOD_NAME(ComponentContext context, int defStyleAttr, int defStyleRes) {\n    Builder builder = sBuilderPool.acquire();\n    if (builder == null) {\n      builder = new Builder();\n    }\n    SimpleLayout instance = new SimpleLayout();\n    builder.init(context, defStyleAttr, defStyleRes, instance);\n    return builder;\n  }\n\n  public static class Builder extends Component.Builder<Builder> {\n    SimpleLayout mSimpleLayout;\n\n    ComponentContext mContext;\n\n    private void init(ComponentContext context, int defStyleAttr, int defStyleRes,\n        SimpleLayout simpleLayoutRef) {\n      super.init(context, defStyleAttr, defStyleRes, simpleLayoutRef);\n      mSimpleLayout = simpleLayoutRef;\n      mContext = context;\n    }\n\n    @Override\n    public Builder getThis() {\n      return this;\n    }\n\n    @Override\n    public SimpleLayout build() {\n      SimpleLayout simpleLayoutRef = mSimpleLayout;\n      release();\n      return simpleLayoutRef;\n    }\n\n    @Override\n    protected void release() {\n      super.release();\n      mSimpleLayout = null;\n      mContext = null;\n      sBuilderPool.release(this);\n    }\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static com.facebook.litho.it.R.attr.testAttrLargePadding;\nimport static com.facebook.litho.it.R.attr.testAttrLargeText;\nimport static com.facebook.litho.it.R.style.PaddingStyle;\nimport static com.facebook.litho.it.R.style.TextSizeStyle;\nimport static com.facebook.yoga.YogaEdge.ALL;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.powermock.reflect.Whitebox.getInternalState;\n\nimport android.view.ContextThemeWrapper;\nimport com.facebook.litho.it.R;\nimport com.facebook.litho.testing.ComponentsRule;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.widget.Text;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\n@org.junit.Ignore(\"t16280359\")\npublic class ComponentStyleTest {\n  private int mDimen;\n  private int mLargeDimen;\n  private ComponentContext mContext;\n\n  @Rule\n  public ComponentsRule mComponentsRule = new ComponentsRule();\n\n  @Before\n  public void METHOD_NAME() {\n    mContext = new ComponentContext(\n        new ContextThemeWrapper(RuntimeEnvironment.application, R.style.TestTheme));\n    mDimen = mContext.getResources().getDimensionPixelSize(R.dimen.test_dimen);\n    mLargeDimen = mContext.getResources().getDimensionPixelSize(R.dimen.test_large_dimen);\n  }\n\n  @Test\n  public void testStyleProp() {\n    Component component =\n        Text.create(mContext, 0, TextSizeStyle)\n            .text(\"text\")\n            .build();\n    assertThat((int) getInternalState(component, \"textSize\"))\n        .isEqualTo(mDimen);\n  }\n\n  @Test\n  public void testOverrideStyleProp() {\n    Component component =\n        Text.create(mContext, 0, TextSizeStyle)\n            .text(\"text\")\n            .textSizePx(2 * mDimen)\n            .build();\n    assertThat((int) getInternalState(component, \"textSize\"))\n        .isEqualTo(2 * mDimen);\n  }\n\n  @Test\n  public void testStyleLayout() {\n    Component component = Text.create(mContext, 0, PaddingStyle).text(\"text\").build();\n    InternalNode node = (InternalNode) component.resolve(mContext);\n    node.calculateLayout();\n    assertThat(node.getPaddingLeft()).isEqualTo(mDimen);\n  }\n\n  @Test\n  public void testOverrideStyleLayout() {\n    Component component =\n        Text.create(mContext, 0, PaddingStyle)\n            .text(\"text\")\n            .paddingPx(ALL, mDimen * 2)\n            .build();\n    InternalNode node = (InternalNode) component.resolve(mContext);\n    node.calculateLayout();\n    assertThat(node.getPaddingLeft()).isEqualTo(2 * mDimen);\n  }\n\n  @Test\n  public void testAttributeStyleProp() {\n    Component component =\n        Text.create(mContext, testAttrLargeText, 0)\n            .text(\"text\")\n            .build();\n    assertThat((int) getInternalState(component, \"textSize\"))\n        .isEqualTo(mLargeDimen);\n  }\n\n  @Test\n  public void testOverrideAttributeStyleProp() {\n    Component component =\n        Text.create(mContext, testAttrLargeText, 0)\n            .text(\"text\")\n            .textSizePx(mDimen)\n            .build();\n    assertThat((int) getInternalState(component, \"textSize\"))\n        .isEqualTo(mDimen);\n  }\n\n  @Test\n  public void testAttributeStyleLayout() {\n    Component component =\n        Text.create(mContext, testAttrLargePadding, 0).text(\"text\").build();\n    InternalNode node = (InternalNode) component.resolve(mContext);\n    node.calculateLayout();\n    assertThat(node.getPaddingLeft()).isEqualTo(mLargeDimen);\n  }\n\n  @Test\n  public void testOverrideAttributeStyleLayout() {\n    Component component =\n        Text.create(mContext, testAttrLargePadding, 0)\n            .text(\"text\")\n            .paddingPx(ALL, mDimen * 2)\n            .build();\n    InternalNode node = (InternalNode) component.resolve(mContext);\n    node.calculateLayout();\n    assertThat(node.getPaddingLeft()).isEqualTo(2 * mDimen);\n  }\n\n  @Test\n  public void testStyleResOverridenByAttrResForProp() {\n    Component component =\n        Text.create(mContext, testAttrLargeText, TextSizeStyle)\n            .text(\"text\")\n            .build();\n    assertThat((int) getInternalState(component, \"textSize\"))\n        .isEqualTo(mLargeDimen);\n  }\n\n  @Test\n  public void testStyleResOverridenByAttrResForLayout() {\n    Component component =\n        Text.create(mContext, testAttrLargePadding, PaddingStyle).text(\"text\").build();\n    InternalNode node = (InternalNode) component.resolve(mContext);\n    node.calculateLayout();\n    assertThat(node.getPaddingLeft()).isEqualTo(mLargeDimen);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static com.facebook.litho.LayoutState.createAndMeasureTreeForComponent;\nimport static com.facebook.litho.SizeSpec.UNSPECIFIED;\nimport static com.facebook.litho.SizeSpec.makeSizeSpec;\nimport static com.facebook.yoga.YogaDirection.RTL;\nimport static com.facebook.yoga.YogaEdge.BOTTOM;\nimport static com.facebook.yoga.YogaEdge.END;\nimport static com.facebook.yoga.YogaEdge.LEFT;\nimport static com.facebook.yoga.YogaEdge.RIGHT;\nimport static com.facebook.yoga.YogaEdge.START;\nimport static com.facebook.yoga.YogaEdge.TOP;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.yoga.YogaDirection;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class InternalNodeTouchExpansionTest {\n  private InternalNode mInternalNode;\n\n  @Before\n  public void METHOD_NAME() {\n    final ComponentContext context = new ComponentContext(RuntimeEnvironment.application);\n    mInternalNode =\n        createAndMeasureTreeForComponent(\n            context,\n            Column.create(context).build(),\n            makeSizeSpec(0, UNSPECIFIED),\n            makeSizeSpec(0, UNSPECIFIED));\n\n    mInternalNode.touchHandler(new EventHandler(null, 1));\n  }\n\n  private static void setDirection(InternalNode node, YogaDirection direction) {\n    node.layoutDirection(direction);\n    node.calculateLayout();\n  }\n\n  @Test\n  public void testTouchExpansionLeftWithoutTouchHandling() {\n    mInternalNode.touchHandler(null);\n    mInternalNode.touchExpansionPx(LEFT, 10);\n    assertThat(mInternalNode.getTouchExpansionLeft()).isEqualTo(0);\n  }\n\n  @Test\n  public void testTouchExpansionTopWithoutTouchHandling() {\n    mInternalNode.touchHandler(null);\n    mInternalNode.touchExpansionPx(TOP, 10);\n    assertThat(mInternalNode.getTouchExpansionTop()).isEqualTo(0);\n  }\n\n  @Test\n  public void testTouchExpansionRightWithoutTouchHandling() {\n    mInternalNode.touchHandler(null);\n    mInternalNode.touchExpansionPx(RIGHT, 10);\n    assertThat(mInternalNode.getTouchExpansionRight()).isEqualTo(0);\n  }\n\n  @Test\n  public void testTouchExpansionBottomWithoutTouchHandling() {\n    mInternalNode.touchHandler(null);\n    mInternalNode.touchExpansionPx(BOTTOM, 10);\n    assertThat(mInternalNode.getTouchExpansionBottom()).isEqualTo(0);\n  }\n\n  @Test\n  public void testTouchExpansionLeftWithUndefinedStartEnd() {\n    mInternalNode.touchExpansionPx(LEFT, 10);\n    assertThat(mInternalNode.getTouchExpansionLeft()).isEqualTo(10);\n  }\n\n  @Test\n  public void testTouchExpansionLeftWithDefinedStart() {\n    mInternalNode.touchExpansionPx(START, 5);\n    mInternalNode.touchExpansionPx(LEFT, 10);\n    assertThat(mInternalNode.getTouchExpansionLeft()).isEqualTo(5);\n  }\n\n  @Test\n  public void testTouchExpansionLeftWithDefinedEnd() {\n    mInternalNode.touchExpansionPx(END, 5);\n    mInternalNode.touchExpansionPx(LEFT, 10);\n    assertThat(mInternalNode.getTouchExpansionLeft()).isEqualTo(10);\n  }\n\n  @Test\n  public void testTouchExpansionLeftWithDefinedStartInRtl() {\n    setDirection(mInternalNode, RTL);\n    mInternalNode.touchExpansionPx(START, 5);\n    mInternalNode.touchExpansionPx(LEFT, 10);\n    assertThat(mInternalNode.getTouchExpansionLeft()).isEqualTo(10);\n  }\n\n  @Test\n  public void testTouchExpansionLeftWithDefinedEndInRtl() {\n    setDirection(mInternalNode, RTL);\n    mInternalNode.touchExpansionPx(END, 5);\n    mInternalNode.touchExpansionPx(LEFT, 10);\n    assertThat(mInternalNode.getTouchExpansionLeft()).isEqualTo(5);\n  }\n\n  @Test\n  public void testTouchExpansionRightWithUndefinedStartEnd() {\n    mInternalNode.touchExpansionPx(RIGHT, 10);\n    assertThat(mInternalNode.getTouchExpansionRight()).isEqualTo(10);\n  }\n\n  @Test\n  public void testTouchExpansionRightWithDefinedStart() {\n    mInternalNode.touchExpansionPx(START, 5);\n    mInternalNode.touchExpansionPx(RIGHT, 10);\n    assertThat(mInternalNode.getTouchExpansionRight()).isEqualTo(10);\n  }\n\n  @Test\n  public void testTouchExpansionRightWithDefinedEnd() {\n    mInternalNode.touchExpansionPx(END, 5);\n    mInternalNode.touchExpansionPx(RIGHT, 10);\n    assertThat(mInternalNode.getTouchExpansionRight()).isEqualTo(5);\n  }\n\n  @Test\n  public void testTouchExpansionRightWithDefinedStartInRtl() {\n    setDirection(mInternalNode, RTL);\n    mInternalNode.touchExpansionPx(START, 5);\n    mInternalNode.touchExpansionPx(RIGHT, 10);\n    assertThat(mInternalNode.getTouchExpansionRight()).isEqualTo(5);\n  }\n\n  @Test\n  public void testTouchExpansionRightWithDefinedEndInRtl() {\n    setDirection(mInternalNode, RTL);\n    mInternalNode.touchExpansionPx(END, 5);\n    mInternalNode.touchExpansionPx(RIGHT, 10);\n    assertThat(mInternalNode.getTouchExpansionRight()).isEqualTo(10);\n  }\n}\n"}
{"label": "test|round|positive|up", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static com.facebook.litho.FastMath.round;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class FastMathTest {\n\n  @Test\n  public void METHOD_NAME() {\n    assertThat(2).isEqualTo(round(1.6f));\n  }\n\n  @Test\n  public void testRoundPositiveDown() {\n    assertThat(1).isEqualTo(round(1.3f));\n  }\n\n  @Test\n  public void testRoundZero() {\n    assertThat(0).isEqualTo(round(0f));\n  }\n\n  @Test\n  public void testRoundNegativeUp() {\n    assertThat(-1).isEqualTo(round(-1.3f));\n  }\n\n  @Test\n  public void testRoundNegativeDown() {\n    assertThat(-2).isEqualTo(round(-1.6f));\n  }\n\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static android.graphics.Color.BLACK;\nimport static android.graphics.Color.YELLOW;\nimport static com.facebook.litho.testing.TestDrawableComponent.create;\nimport static com.facebook.litho.testing.helper.ComponentTestHelper.mountComponent;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.robolectric.Shadows.shadowOf;\n\nimport android.graphics.drawable.ColorDrawable;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class ComponentTreeMountTest {\n\n  private ComponentContext mContext;\n\n  @Before\n  public void METHOD_NAME() {\n    mContext = new ComponentContext(RuntimeEnvironment.application);\n  }\n\n  @Test\n  public void testRemountsWithNewInputOnSameLayout() {\n    final LithoView lithoView = mountComponent(\n        mContext,\n        create(mContext)\n            .color(BLACK)\n            .build());\n    shadowOf(lithoView).callOnAttachedToWindow();\n\n    assertThat(lithoView.getDrawables()).hasSize(1);\n    assertThat(((ColorDrawable) lithoView.getDrawables().get(0)).getColor()).isEqualTo(BLACK);\n\n    lithoView.getComponentTree().setRoot(\n        create(mContext)\n            .color(YELLOW)\n            .build());\n    assertThat(lithoView.getDrawables()).hasSize(1);\n    assertThat(((ColorDrawable) lithoView.getDrawables().get(0)).getColor()).isEqualTo(YELLOW);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static com.facebook.litho.Column.create;\nimport static com.facebook.litho.testing.helper.ComponentTestHelper.mountComponent;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.testing.TestDrawableComponent;\nimport com.facebook.litho.testing.TestViewComponent;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.testing.util.InlineLayoutSpec;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class MountStateViewClickTest {\n\n  private ComponentContext mContext;\n\n  @Before\n  public void METHOD_NAME() {\n    mContext = new ComponentContext(RuntimeEnvironment.application);\n  }\n\n  @Test\n  public void testInnerComponentHostClickable() {\n    final LithoView lithoView = mountComponent(\n        mContext,\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            return create(c)\n                .child(\n                    create(c)\n                        .clickHandler(c.newEventHandler(1))\n                        .child(TestViewComponent.create(c)))\n                .build();\n          }\n        });\n\n    assertThat(lithoView.getChildCount()).isEqualTo(1);\n    assertThat(lithoView.isClickable()).isFalse();\n\n    ComponentHost innerHost = (ComponentHost) lithoView.getChildAt(0);\n    assertThat(innerHost.isClickable()).isTrue();\n  }\n\n  @Test\n  public void testInnerComponentHostClickableWithLongClickHandler() {\n    final LithoView lithoView = mountComponent(\n        mContext,\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            return create(c)\n                .child(\n                    create(c)\n                        .longClickHandler(c.newEventHandler(1))\n                        .child(TestViewComponent.create(c)))\n                .build();\n          }\n        });\n\n    assertThat(lithoView.getChildCount()).isEqualTo(1);\n    assertThat(lithoView.isClickable()).isFalse();\n\n    ComponentHost innerHost = (ComponentHost) lithoView.getChildAt(0);\n    assertThat(innerHost.isLongClickable()).isTrue();\n  }\n\n  @Test\n  public void testRootHostClickable() {\n    final LithoView lithoView = mountComponent(\n        mContext,\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            return create(c)\n                .clickHandler(c.newEventHandler(1))\n                .child(TestDrawableComponent.create(c))\n                .build();\n          }\n        });\n\n    assertThat(lithoView.getChildCount()).isEqualTo(0);\n    assertThat(lithoView.isClickable()).isTrue();\n  }\n\n  @Test\n  public void testRootHostClickableWithLongClickHandler() {\n    final LithoView lithoView = mountComponent(\n        mContext,\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            return create(c)\n                .longClickHandler(c.newEventHandler(1))\n                .child(TestDrawableComponent.create(c))\n                .build();\n          }\n        });\n\n    assertThat(lithoView.getChildCount()).isEqualTo(0);\n    assertThat(lithoView.isLongClickable()).isTrue();\n  }\n}\n"}
{"label": "assert|correct|event|handler", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.testing.TestLayoutComponent;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.testing.util.InlineLayoutSpec;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class LayoutStateEventHandlerTest {\n  private int mUnspecifiedSizeSpec = 0; //SizeSpec.makeSizeSpec(0, SizeSpec.UNSPECIFIED);\n\n  private Component mRootComponent;\n  private Component mNestedComponent;\n\n  private static void METHOD_NAME(\n      EventHandler eventHandler,\n      int expectedId,\n      Component expectedInput) {\n    assertThat(eventHandler.mHasEventDispatcher).isEqualTo(expectedInput);\n    assertThat(eventHandler.id).isEqualTo(expectedId);\n  }\n\n  @Before\n  public void setup() {\n    mUnspecifiedSizeSpec = SizeSpec.makeSizeSpec(0, SizeSpec.UNSPECIFIED);\n    mRootComponent =\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            METHOD_NAME(c.newEventHandler(1), 1, mRootComponent);\n            Wrapper.create(c).delegate(mNestedComponent).build();\n            METHOD_NAME(c.newEventHandler(2), 2, mRootComponent);\n            Wrapper.create(c).delegate(mNestedComponent).build();\n            METHOD_NAME(c.newEventHandler(3), 3, mRootComponent);\n\n            return TestLayoutComponent.create(c).build();\n          }\n        };\n    mNestedComponent = new InlineLayoutSpec() {\n      @Override\n      protected ComponentLayout onCreateLayout(ComponentContext c) {\n        METHOD_NAME(c.newEventHandler(1), 1, mNestedComponent);\n\n        return TestLayoutComponent.create(c)\n            .build();\n      }\n    };\n  }\n\n  @Test\n  public void testNestedEventHandlerInput() {\n    LayoutState.calculate(\n        new ComponentContext(RuntimeEnvironment.application),\n        mRootComponent,\n        -1,\n        mUnspecifiedSizeSpec,\n        mUnspecifiedSizeSpec);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.testing.TestLayoutComponent;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.powermock.reflect.Whitebox;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class LayoutStateSpecTest {\n\n  private static final int COMPONENT_ID = 37;\n\n  private int mWidthSpec;\n  private int mHeightSpec;\n  private LayoutState mLayoutState;\n  private Component mComponent;\n  private ComponentContext mContext;\n\n  @Before\n  public void METHOD_NAME() {\n    mContext = new ComponentContext(RuntimeEnvironment.application);\n    mWidthSpec = SizeSpec.makeSizeSpec(39, SizeSpec.EXACTLY);\n    mHeightSpec = SizeSpec.makeSizeSpec(41, SizeSpec.EXACTLY);\n    mComponent = TestLayoutComponent.create(mContext)\n        .build();\n    Whitebox.setInternalState(mComponent, \"mId\", COMPONENT_ID);\n\n    mLayoutState = new LayoutState();\n    Whitebox.setInternalState(mLayoutState, \"mComponent\", mComponent);\n    Whitebox.setInternalState(mLayoutState, \"mWidthSpec\", mWidthSpec);\n    Whitebox.setInternalState(mLayoutState, \"mHeightSpec\", mHeightSpec);\n  }\n\n  @Test\n  public void testCompatibleInputAndSpec() {\n    assertThat(mLayoutState.isCompatibleComponentAndSpec(COMPONENT_ID, mWidthSpec, mHeightSpec)).isTrue();\n  }\n\n  @Test\n  public void testIncompatibleInput() {\n    assertThat(mLayoutState.isCompatibleComponentAndSpec(\n        COMPONENT_ID + 1000, mWidthSpec, mHeightSpec)).isFalse();\n  }\n\n  @Test\n  public void testIncompatibleWidthSpec() {\n    assertThat(mLayoutState.isCompatibleComponentAndSpec(\n        COMPONENT_ID, mWidthSpec + 1000, mHeightSpec)).isFalse();\n  }\n\n  @Test\n  public void testIncompatibleHeightSpec() {\n    assertThat(mLayoutState.isCompatibleComponentAndSpec(\n        COMPONENT_ID, mWidthSpec, mHeightSpec + 1000)).isFalse();\n  }\n}\n"}
{"label": "set|up", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.animation;\n\nimport static com.facebook.litho.animation.AnimatedProperties.SCALE;\nimport static com.facebook.litho.dataflow.GraphBinding.create;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.robolectric.RuntimeEnvironment.application;\n\nimport android.view.View;\nimport com.facebook.litho.dataflow.DataFlowGraph;\nimport com.facebook.litho.dataflow.GraphBinding;\nimport com.facebook.litho.dataflow.MockTimingSource;\nimport com.facebook.litho.dataflow.OutputOnlyNode;\nimport com.facebook.litho.dataflow.SettableNode;\nimport com.facebook.litho.dataflow.SimpleNode;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class AnimatedPropertyNodeTest {\n\n  private MockTimingSource mTestTimingSource;\n  private DataFlowGraph mDataFlowGraph;\n\n  @Before\n  public void METHOD_NAME() throws Exception {\n    mTestTimingSource = new MockTimingSource();\n    mDataFlowGraph = DataFlowGraph.create(mTestTimingSource);\n  }\n\n  @Test\n  public void testViewPropertyNodeWithInput() {\n    View view = new View(application);\n    SettableNode source = new SettableNode();\n    SimpleNode middle = new SimpleNode();\n    AnimatedPropertyNode destination = new AnimatedPropertyNode(view, SCALE);\n\n    GraphBinding binding = create(mDataFlowGraph);\n    binding.addBinding(source, middle);\n    binding.addBinding(middle, destination);\n    binding.activate();\n\n    mTestTimingSource.step(1);\n\n    assertThat(view.getScaleX()).isEqualTo(0f);\n\n    source.setValue(37);\n    mTestTimingSource.step(1);\n\n    assertThat(view.getScaleX()).isEqualTo(37f);\n  }\n\n  @Test\n  public void testViewPropertyNodeWithInputAndOutput() {\n    View view = new View(application);\n    SettableNode source = new SettableNode();\n    AnimatedPropertyNode viewNode = new AnimatedPropertyNode(view, SCALE);\n    OutputOnlyNode destination = new OutputOnlyNode();\n\n    GraphBinding binding = create(mDataFlowGraph);\n    binding.addBinding(source, viewNode);\n    binding.addBinding(viewNode, destination);\n    binding.activate();\n\n    mTestTimingSource.step(1);\n\n    assertThat(view.getScaleX()).isEqualTo(0f);\n    assertThat(destination.getValue()).isEqualTo(0f);\n\n    source.setValue(123);\n    mTestTimingSource.step(1);\n\n    assertThat(view.getScaleX()).isEqualTo(123f);\n    assertThat(destination.getValue()).isEqualTo(123f);\n  }\n\n  @Test\n  public void testSettingMountContentOnNodeWithValue() {\n    View view1 = new View(application);\n    View view2 = new View(application);\n    SettableNode source = new SettableNode();\n    AnimatedPropertyNode viewNode = new AnimatedPropertyNode(view1, SCALE);\n\n    GraphBinding binding = create(mDataFlowGraph);\n    binding.addBinding(source, viewNode);\n    binding.activate();\n\n    mTestTimingSource.step(1);\n\n    assertThat(view1.getScaleX()).isEqualTo(0f);\n\n    source.setValue(123);\n    mTestTimingSource.step(1);\n\n    assertThat(view1.getScaleX()).isEqualTo(123f);\n\n    assertThat(view2.getScaleX()).isEqualTo(1f);\n\n    viewNode.setMountContent(view2);\n\n    assertThat(view2.getScaleX()).isEqualTo(123f);\n  }\n}\n"}
{"label": "test|component|selector|selects|non|null|layout", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.robolectric.RuntimeEnvironment.application;\n\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.testing.util.InlineLayoutSpec;\nimport com.facebook.litho.widget.Image;\nimport com.facebook.litho.widget.Text;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class ComponentSelectorTest {\n\n  private final InlineLayoutSpec mNullSpec =\n      new InlineLayoutSpec() {\n\n        @Override\n        protected ComponentLayout onCreateLayout(ComponentContext c) {\n          return null;\n        }\n      };\n\n  @Test\n  public void METHOD_NAME() throws Exception {\n    ComponentContext c = new ComponentContext(application);\n\n    ComponentLayout nullLayout = Wrapper.create(c).delegate(mNullSpec).build();\n    ComponentLayout textLayout = Text.create(c).text(\"Hello World\").build();\n\n    ComponentLayout actual =\n        ComponentSelector.create(c).tryToRender(nullLayout).tryToRender(textLayout).build();\n\n    assertThat(actual).isEqualTo(textLayout);\n  }\n\n  @Test\n  public void testComponentSelectorSelectsFirstNonNullLayout() throws Exception {\n    ComponentContext c = new ComponentContext(application);\n\n    ComponentLayout nullLayout = Wrapper.create(c).delegate(mNullSpec).build();\n    ComponentLayout imageLayout = Image.create(c).drawable(null).build();\n    ComponentLayout textLayout = Text.create(c).text(\"Hello World\").build();\n\n    ComponentLayout actual =\n        ComponentSelector.create(c)\n            .tryToRender(nullLayout)\n            .tryToRender(imageLayout)\n            .tryToRender(textLayout)\n            .build();\n\n    assertThat(actual).isEqualTo(imageLayout);\n  }\n\n  @Test\n  public void testComponentSelectorSelectsCorrectLayoutWithNullArguments() throws Exception {\n    ComponentContext c = new ComponentContext(application);\n\n    ComponentLayout nullLayout = Wrapper.create(c).delegate(mNullSpec).build();\n    ComponentLayout imageLayout = Image.create(c).drawable(null).build();\n    ComponentLayout textLayout = Text.create(c).text(\"Hello World\").build();\n\n    ComponentLayout actual =\n        ComponentSelector.create(c)\n            .tryToRender(getNullLayout())\n            .tryToRender(getNullLayoutBuilder())\n            .tryToRender(getNullComponent())\n            .tryToRender(getNullComponentBuilder())\n            .tryToRender(nullLayout)\n            .tryToRender(imageLayout)\n            .tryToRender(textLayout)\n            .build();\n\n    assertThat(actual).isEqualTo(imageLayout);\n  }\n\n  @Test\n  public void testComponentSelectorSelectsLastLayoutWhenNoneRender() throws Exception {\n    ComponentContext c = new ComponentContext(application);\n\n    ComponentLayout nullLayout = Wrapper.create(c).delegate(mNullSpec).build();\n    ComponentLayout nullLayout2 = Wrapper.create(c).delegate(mNullSpec).build();\n    ComponentLayout nullLayout3 = Wrapper.create(c).delegate(mNullSpec).build();\n\n    ComponentLayout actual =\n        ComponentSelector.create(c)\n            .tryToRender(nullLayout)\n            .tryToRender(nullLayout2)\n            .tryToRender(nullLayout3)\n            .build();\n\n    // Currently, all 3 layouts point to the same object and the behavior would be identical\n    // regardless of which layout is selected. So this test is moot. However, this implementation\n    // detail could change in the future.\n    assertThat(actual).isEqualTo(nullLayout3);\n  }\n\n  @Test\n  public void testComponentSelectorWithNoArgumentsReturnsNull() throws Exception {\n    ComponentContext c = new ComponentContext(application);\n\n    ComponentLayout actual = ComponentSelector.create(c).build();\n\n    assertThat(actual).isNull();\n  }\n\n  private static ComponentLayout getNullLayout() {\n    return null;\n  }\n\n  private static ComponentLayout.Builder getNullLayoutBuilder() {\n    return null;\n  }\n\n  private static Component getNullComponent() {\n    return null;\n  }\n\n  private static Component.Builder getNullComponentBuilder() {\n    return null;\n  }\n}\n"}
{"label": "test|orientations", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static android.support.v7.widget.OrientationHelper.HORIZONTAL;\nimport static android.support.v7.widget.OrientationHelper.VERTICAL;\nimport static com.facebook.litho.SizeSpec.EXACTLY;\nimport static com.facebook.litho.SizeSpec.UNSPECIFIED;\nimport static com.facebook.litho.SizeSpec.makeSizeSpec;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.robolectric.RuntimeEnvironment.application;\n\nimport android.support.v7.widget.LinearLayoutManager;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n/**\n * Tests for {@link LinearLayoutInfo}\n */\n@RunWith(ComponentsTestRunner.class)\npublic class LinearLayoutInfoTest {\n\n  @Test\n  public void METHOD_NAME() {\n    final LinearLayoutInfo verticalLinearLayoutInfo = new LinearLayoutInfo(\n        application,\n        VERTICAL,\n        false);\n\n    assertThat(VERTICAL).isEqualTo(verticalLinearLayoutInfo.getScrollDirection());\n\n    final LinearLayoutInfo horizontalLinearLayoutInfo = new LinearLayoutInfo(\n        application,\n        HORIZONTAL,\n        false);\n\n    assertThat(HORIZONTAL).isEqualTo(horizontalLinearLayoutInfo.getScrollDirection());\n  }\n\n  @Test\n  public void testGetLayoutManager() {\n    final LinearLayoutInfo linearLayoutInfo = new LinearLayoutInfo(\n        application,\n        VERTICAL,\n        false);\n\n    assertThat(linearLayoutInfo.getLayoutManager()).isInstanceOf(LinearLayoutManager.class);\n  }\n\n  @Test\n  public void testApproximateRangeVertical() {\n    final LinearLayoutInfo linearLayoutInfo = new LinearLayoutInfo(\n        application,\n        VERTICAL,\n        false);\n\n    int rangeSize = linearLayoutInfo.approximateRangeSize(10, 10, 10, 100);\n\n    assertThat(rangeSize).isEqualTo(10);\n  }\n\n  @Test\n  public void testApproximateRangeHorizontal() {\n    final LinearLayoutInfo linearLayoutInfo = new LinearLayoutInfo(\n        application,\n        HORIZONTAL,\n        false);\n\n    int rangeSize = linearLayoutInfo.approximateRangeSize(10, 10, 100, 10);\n\n    assertThat(rangeSize).isEqualTo(10);\n  }\n\n  @Test\n  public void testGetChildMeasureSpecVertical() {\n    final LinearLayoutInfo linearLayoutInfo = new LinearLayoutInfo(\n        application,\n        VERTICAL,\n        false);\n    final int sizeSpec = makeSizeSpec(200, EXACTLY);\n\n    final int heightSpec = linearLayoutInfo.getChildHeightSpec(sizeSpec, null);\n    assertThat(makeSizeSpec(0, UNSPECIFIED)).isEqualTo(heightSpec);\n\n    final int widthSpec = linearLayoutInfo.getChildWidthSpec(sizeSpec, null);\n    assertThat(sizeSpec).isEqualTo(widthSpec);\n  }\n\n  @Test\n  public void testGetChildMeasureSpecHorizontal() {\n    final LinearLayoutInfo linearLayoutInfo = new LinearLayoutInfo(\n        application,\n        HORIZONTAL,\n        false);\n    final int sizeSpec = makeSizeSpec(200, EXACTLY);\n\n    final int heightSpec = linearLayoutInfo.getChildHeightSpec(sizeSpec, null);\n    assertThat(sizeSpec).isEqualTo(heightSpec);\n\n    final int widthSpec = linearLayoutInfo.getChildWidthSpec(sizeSpec, null);\n    assertThat(makeSizeSpec(0, UNSPECIFIED)).isEqualTo(widthSpec);\n  }\n}\n"}
{"label": "test|orientation", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static android.support.v7.widget.OrientationHelper.HORIZONTAL;\nimport static android.support.v7.widget.OrientationHelper.VERTICAL;\nimport static com.facebook.litho.SizeSpec.EXACTLY;\nimport static com.facebook.litho.SizeSpec.UNSPECIFIED;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport android.support.v7.widget.GridLayoutManager;\nimport com.facebook.litho.SizeSpec;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class GridLayoutInfoTest {\n\n  @Test\n  public void METHOD_NAME() {\n    final GridLayoutInfo verticalGridLayoutInfo = createGridLayoutInfo(VERTICAL, 2);\n\n    assertThat(verticalGridLayoutInfo.getScrollDirection()).isEqualTo(VERTICAL);\n\n    final GridLayoutInfo horizontalGridLayoutInfo = createGridLayoutInfo(HORIZONTAL, 2);\n\n    assertThat(horizontalGridLayoutInfo.getScrollDirection()).isEqualTo(HORIZONTAL);\n  }\n\n  @Test\n  public void testLayoutManagerIsGrid() {\n    final GridLayoutInfo gridLayoutInfo = createGridLayoutInfo(VERTICAL, 2);\n\n    assertThat(gridLayoutInfo.getLayoutManager()).isInstanceOf(GridLayoutManager.class);\n  }\n\n  @Test\n  public void testApproximateRangeVertical() {\n    final GridLayoutInfo gridLayoutInfo = createGridLayoutInfo(VERTICAL, 3);\n    int rangeSize = gridLayoutInfo.approximateRangeSize(10, 10, 30, 100);\n\n    assertThat(rangeSize).isEqualTo(30);\n  }\n\n  @Test\n  public void testApproximateRangeHorizontal() {\n    final GridLayoutInfo gridLayoutInfo = createGridLayoutInfo(HORIZONTAL, 2);\n    int rangeSize = gridLayoutInfo.approximateRangeSize(15, 10, 100, 20);\n\n    assertThat(rangeSize).isEqualTo(14);\n  }\n\n  @Test\n  public void testGetChildMeasureSpecVertical() {\n    final GridLayoutInfo gridLayoutInfo = createGridLayoutInfo(VERTICAL, 3);\n    final int sizeSpec = SizeSpec.makeSizeSpec(200, EXACTLY);\n\n    final RenderInfo renderInfo = mock(RenderInfo.class);\n    when(renderInfo.getSpanSize()).thenReturn(2);\n\n    final int heightSpec = gridLayoutInfo.getChildHeightSpec(sizeSpec, renderInfo);\n    assertThat(SizeSpec.getMode(heightSpec)).isEqualTo(UNSPECIFIED);\n\n    final int widthSpec = gridLayoutInfo.getChildWidthSpec(sizeSpec, renderInfo);\n\n    assertThat(SizeSpec.getSize(widthSpec)).isEqualTo((200 / 3) * 2);\n    assertThat(SizeSpec.getMode(widthSpec)).isEqualTo(EXACTLY);\n  }\n\n  @Test\n  public void testGetChildMeasureSpecOverride() {\n    final GridLayoutInfo gridLayoutInfo = createGridLayoutInfo(VERTICAL, 3);\n    final int sizeSpec = SizeSpec.makeSizeSpec(200, EXACTLY);\n\n    final RenderInfo renderInfo = mock(RenderInfo.class);\n    when(renderInfo.getSpanSize()).thenReturn(2);\n    when(renderInfo.getCustomAttribute(GridLayoutInfo.OVERRIDE_SIZE)).thenReturn(20);\n\n    final int heightSpec = gridLayoutInfo.getChildHeightSpec(sizeSpec, renderInfo);\n    assertThat(SizeSpec.getMode(heightSpec)).isEqualTo(UNSPECIFIED);\n\n    final int widthSpec = gridLayoutInfo.getChildWidthSpec(sizeSpec, renderInfo);\n\n    assertThat(SizeSpec.getSize(widthSpec)).isEqualTo(20);\n    assertThat(SizeSpec.getMode(widthSpec)).isEqualTo(EXACTLY);\n  }\n\n  @Test\n  public void testGetChildMeasureSpecHorizontal() {\n    final GridLayoutInfo gridLayoutInfo = createGridLayoutInfo(HORIZONTAL, 3);\n    final int sizeSpec = SizeSpec.makeSizeSpec(200, EXACTLY);\n\n    final RenderInfo renderInfo = mock(RenderInfo.class);\n    when(renderInfo.getSpanSize()).thenReturn(2);\n\n    final int heightSpec = gridLayoutInfo.getChildHeightSpec(sizeSpec, renderInfo);\n    assertThat(SizeSpec.getSize(heightSpec)).isEqualTo((200 / 3) * 2);\n    assertThat(SizeSpec.getMode(heightSpec)).isEqualTo(EXACTLY);\n\n    final int widthSpec = gridLayoutInfo.getChildWidthSpec(sizeSpec, renderInfo);\n    assertThat(SizeSpec.getMode(widthSpec)).isEqualTo(UNSPECIFIED);\n  }\n\n  private static GridLayoutInfo createGridLayoutInfo(int direction, int spanCount) {\n    return new GridLayoutInfo(RuntimeEnvironment.application, spanCount, direction, false);\n  }\n}\n"}
{"label": "set|up", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static com.facebook.litho.testing.assertj.ComponentConditions.typeIs;\nimport static com.facebook.litho.testing.assertj.SubComponentDeepExtractor.deepSubComponentWith;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assume.assumeThat;\n\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.config.ComponentsConfiguration;\nimport com.facebook.litho.testing.assertj.ComponentAssert;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.testing.util.InlineLayoutSpec;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n/** Tests {@link SelectorComponentSpec}. */\n@RunWith(ComponentsTestRunner.class)\npublic class SelectorComponentSpecTest {\n\n  private final InlineLayoutSpec mNullSpec =\n      new InlineLayoutSpec() {\n\n        @Override\n        protected ComponentLayout onCreateLayout(ComponentContext c) {\n          return null;\n        }\n      };\n\n  private ComponentContext mContext;\n\n  @Before\n  public void METHOD_NAME() throws Exception {\n    assumeThat(\n        \"These tests can only be run in debug mode.\",\n        ComponentsConfiguration.IS_INTERNAL_BUILD,\n        is(true));\n    mContext = new ComponentContext(RuntimeEnvironment.application);\n  }\n\n  @Test\n  public void testFirstComponentSelected() throws Exception {\n    ComponentAssert.assertThat(\n            SelectorComponent.create(mContext)\n                .component(Image.create(mContext).drawable(null))\n                .component(Text.create(mContext).text(\"Hello World\")))\n        .has(deepSubComponentWith(mContext, typeIs(Image.class)));\n  }\n\n  @Test\n  public void testNullArgument() throws Exception {\n    ComponentAssert.assertThat(\n            SelectorComponent.create(mContext)\n                .component((Component) null)\n                .component(Image.create(mContext).drawable(null))\n                .component(Text.create(mContext).text(\"Hello World\")))\n        .has(deepSubComponentWith(mContext, typeIs(Image.class)));\n  }\n\n  @Test\n  public void testNullLayoutSkipped() throws Exception {\n    ComponentAssert.assertThat(\n            SelectorComponent.create(mContext)\n                .component(mNullSpec)\n                .component(Image.create(mContext).drawable(null))\n                .component(Text.create(mContext).text(\"Hello World\")))\n        .has(deepSubComponentWith(mContext, typeIs(Image.class)));\n  }\n\n  @Test\n  public void testEmpty() throws Exception {\n    ComponentAssert.assertThat(\n            SelectorComponent.create(mContext).component(mNullSpec).component((Component) null))\n        .willNotRender();\n  }\n\n  @Test\n  public void testAllNull() throws Exception {\n    ComponentAssert.assertThat(\n            SelectorComponent.create(mContext)\n                .component((Component) null)\n                .component((Component) null))\n        .willNotRender();\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyFloat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.support.v7.widget.RecyclerView;\nimport com.facebook.litho.ComponentTree;\nimport com.facebook.litho.LithoView;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.RunWith;\n\n/**\n * Tests for {@link StickyHeaderController}\n */\n@RunWith(ComponentsTestRunner.class)\npublic class StickyHeaderControllerTest {\n\n  private HasStickyHeader mHasStickyHeader;\n  private StickyHeaderController mStickyHeaderController;\n\n  @Rule\n  public ExpectedException thrown = ExpectedException.none();\n\n  @Before\n  public void METHOD_NAME() {\n    mHasStickyHeader = mock(HasStickyHeader.class);\n    mStickyHeaderController = new StickyHeaderController(mHasStickyHeader);\n  }\n\n  @Test\n  public void testInitNoLayoutManager() {\n    RecyclerViewWrapper wrapper = mock(RecyclerViewWrapper.class);\n    RecyclerView recyclerView = mock(RecyclerView.class);\n    when(wrapper.getRecyclerView()).thenReturn(recyclerView);\n\n    thrown.expect(RuntimeException.class);\n    thrown.expectMessage(StickyHeaderController.LAYOUTMANAGER_NOT_INITIALIZED);\n    mStickyHeaderController.init(wrapper);\n  }\n\n  @Test\n  public void testInitTwiceWithoutReset() {\n    RecyclerViewWrapper wrapper1 = mock(RecyclerViewWrapper.class);\n    RecyclerView recyclerView1 = mock(RecyclerView.class);\n    when(wrapper1.getRecyclerView()).thenReturn(recyclerView1);\n    when(recyclerView1.getLayoutManager()).thenReturn(mock(RecyclerView.LayoutManager.class));\n    mStickyHeaderController.init(wrapper1);\n\n    RecyclerViewWrapper wrapper2 = mock(RecyclerViewWrapper.class);\n    RecyclerView recyclerView2 = mock(RecyclerView.class);\n    when(recyclerView2.getLayoutManager()).thenReturn(mock(RecyclerView.LayoutManager.class));\n    when(wrapper2.getRecyclerView()).thenReturn(recyclerView2);\n\n    thrown.expect(RuntimeException.class);\n    thrown.expectMessage(StickyHeaderController.WRAPPER_ALREADY_INITIALIZED);\n    mStickyHeaderController.init(wrapper2);\n  }\n\n  @Test\n  public void testResetBeforeInit() {\n    thrown.expect(RuntimeException.class);\n    thrown.expectMessage(StickyHeaderController.WRAPPER_NOT_INITIALIZED);\n\n    mStickyHeaderController.reset();\n  }\n\n  @Test\n  public void testTranslateRecyclerViewChild() {\n    RecyclerViewWrapper wrapper = mock(RecyclerViewWrapper.class);\n    RecyclerView recyclerView = mock(RecyclerView.class);\n    when(wrapper.getRecyclerView()).thenReturn(recyclerView);\n    when(recyclerView.getLayoutManager()).thenReturn(mock(RecyclerView.LayoutManager.class));\n    mStickyHeaderController.init(wrapper);\n\n    when(mHasStickyHeader.findFirstVisibleItemPosition()).thenReturn(2);\n    when(mHasStickyHeader.isSticky(2)).thenReturn(true);\n\n    ComponentTree componentTree = mock(ComponentTree.class);\n    when(mHasStickyHeader.getComponentAt(2)).thenReturn(componentTree);\n    LithoView lithoView = mock(LithoView.class);\n    when(componentTree.getLithoView()).thenReturn(lithoView);\n\n    mStickyHeaderController.onScrolled(null, 0, 0);\n\n    verify(lithoView).setTranslationY(anyFloat());\n    verify(wrapper, times(2)).hideStickyHeader();\n  }\n\n  @Test\n  public void testTranslateWrapperChild() {\n    RecyclerViewWrapper wrapper = mock(RecyclerViewWrapper.class);\n    RecyclerView recyclerView = mock(RecyclerView.class);\n    when(wrapper.getRecyclerView()).thenReturn(recyclerView);\n    when(recyclerView.getLayoutManager()).thenReturn(mock(RecyclerView.LayoutManager.class));\n    mStickyHeaderController.init(wrapper);\n\n    when(mHasStickyHeader.findFirstVisibleItemPosition()).thenReturn(6);\n    when(mHasStickyHeader.isSticky(2)).thenReturn(true);\n\n    when(mHasStickyHeader.getComponentAt(2)).thenReturn(mock(ComponentTree.class));\n    when(mHasStickyHeader.getComponentAt(6)).thenReturn(mock(ComponentTree.class));\n\n    mStickyHeaderController.onScrolled(null, 0, 0);\n\n    verify(wrapper).setStickyHeaderVerticalOffset(any(Integer.class));\n  }\n\n  @Test\n  public void testTranslateStackedStickyHeaders() {\n    RecyclerViewWrapper wrapper = mock(RecyclerViewWrapper.class);\n    RecyclerView recyclerView = mock(RecyclerView.class);\n    when(wrapper.getRecyclerView()).thenReturn(recyclerView);\n    when(recyclerView.getLayoutManager()).thenReturn(mock(RecyclerView.LayoutManager.class));\n    mStickyHeaderController.init(wrapper);\n\n    when(mHasStickyHeader.findFirstVisibleItemPosition()).thenReturn(2);\n    when(mHasStickyHeader.isSticky(2)).thenReturn(true);\n    when(mHasStickyHeader.isSticky(3)).thenReturn(true);\n    when(mHasStickyHeader.isValidPosition(3)).thenReturn(true);\n\n    ComponentTree componentTree = mock(ComponentTree.class);\n    when(mHasStickyHeader.getComponentAt(2)).thenReturn(componentTree);\n    LithoView lithoView = mock(LithoView.class);\n    when(componentTree.getLithoView()).thenReturn(lithoView);\n\n    mStickyHeaderController.onScrolled(null, 0, 0);\n\n    verify(lithoView, never()).setTranslationY(any(Integer.class));\n    verify(wrapper, times(2)).hideStickyHeader();\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\nimport android.graphics.Canvas;\nimport android.graphics.Picture;\nimport android.text.Layout;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.Shadows;\nimport org.robolectric.annotation.Config;\nimport org.robolectric.annotation.Implementation;\nimport org.robolectric.annotation.Implements;\nimport org.robolectric.shadows.ShadowLooper;\n\n/**\n * Tests {@link GlyphWarmer}.\n */\n@RunWith(ComponentsTestRunner.class)\n@Config(shadows = GlyphWarmerTest.ShadowPicture.class)\npublic class GlyphWarmerTest {\n  private ShadowLooper mShadowLooper;\n  private GlyphWarmer mGlyphWarmer;\n\n  @Before\n  public void METHOD_NAME() {\n    mGlyphWarmer = GlyphWarmer.getInstance();\n    mShadowLooper = Shadows.shadowOf(mGlyphWarmer.getWarmerLooper());\n  }\n\n  @Test\n  public void testWarmGlyph() {\n    Layout layout = mock(Layout.class);\n    mGlyphWarmer.warmLayout(layout);\n    mShadowLooper.runOneTask();\n    verify(layout).draw(any(Canvas.class));\n  }\n\n  @Implements(Picture.class)\n  public static class ShadowPicture {\n\n    @Implementation\n    public void __constructor__(int nativePicture, boolean fromStream) {\n\n    }\n\n    @Implementation\n    public void __constructor__(int nativePicture) {\n\n    }\n\n    @Implementation\n    public void __constructor__() {\n\n    }\n\n    @Implementation\n    public Canvas beginRecording(int width, int height) {\n      return new Canvas();\n    }\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.support.v4.widget.SwipeRefreshLayout.OnRefreshListener;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.RecyclerView.ItemAnimator;\nimport android.support.v7.widget.RecyclerView.OnScrollListener;\nimport android.support.v7.widget.SnapHelper;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.Output;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n/**\n * Tests for {@link RecyclerSpec}\n */\n@RunWith(ComponentsTestRunner.class)\npublic class RecyclerSpecTest {\n\n  private ComponentContext mComponentContext;\n  private RecyclerViewWrapper mRecyclerViewWrapper;\n  private LithoRecylerView mRecyclerView;\n  private ItemAnimator mAnimator;\n\n  @Before\n  public void METHOD_NAME() {\n    mComponentContext = new ComponentContext(RuntimeEnvironment.application);\n    mRecyclerViewWrapper = mock(RecyclerViewWrapper.class);\n    mRecyclerView = mock(LithoRecylerView.class);\n    when(mRecyclerViewWrapper.getRecyclerView()).thenReturn(mRecyclerView);\n    when(mRecyclerViewWrapper.hasBeenDetachedFromWindow()).thenReturn(true);\n\n    mAnimator = mock(RecyclerView.ItemAnimator.class);\n    when(mRecyclerView.getItemAnimator()).thenReturn(mAnimator);\n  }\n\n  @Test\n  public void testRecyclerSpecOnBind() {\n    OnRefreshListener onRefreshListener = mock(OnRefreshListener.class);\n    Binder<RecyclerView> binder = mock(Binder.class);\n\n    Output<ItemAnimator> oldAnimator = mock(Output.class);\n\n    SnapHelper snapHelper = mock(SnapHelper.class);\n\n    final int size = 3;\n    List<RecyclerView.OnScrollListener> scrollListeners = createListOfScrollListeners(size);\n\n    LithoRecylerView.TouchInterceptor touchInterceptor =\n        mock(LithoRecylerView.TouchInterceptor.class);\n\n    RecyclerSpec.onBind(\n        mComponentContext,\n        mRecyclerViewWrapper,\n        mAnimator,\n        binder,\n        null,\n        scrollListeners,\n        snapHelper,\n        true,\n        touchInterceptor,\n        onRefreshListener,\n        oldAnimator);\n\n    verify(mRecyclerViewWrapper).setEnabled(true);\n    verify(mRecyclerViewWrapper).setOnRefreshListener(onRefreshListener);\n    verify(mRecyclerViewWrapper, times(1)).getRecyclerView();\n    verify(oldAnimator).set(mAnimator);\n    verify(mRecyclerView).setItemAnimator(any(ItemAnimator.class));\n    verify(mRecyclerView, times(size)).addOnScrollListener(any(OnScrollListener.class));\n    verify(mRecyclerView).setTouchInterceptor(touchInterceptor);\n    verify(binder).bind(mRecyclerView);\n    verify(mRecyclerView, times(1)).requestLayout();\n    verify(mRecyclerViewWrapper).setHasBeenDetachedFromWindow(false);\n  }\n\n  @Test\n  public void testRecyclerSpecOnUnbind() {\n    when(mRecyclerViewWrapper.hasBeenDetachedFromWindow()).thenReturn(true);\n\n    Binder<RecyclerView> binder = mock(Binder.class);\n\n    SnapHelper snapHelper = mock(SnapHelper.class);\n\n    final int size = 3;\n    List<RecyclerView.OnScrollListener> scrollListeners = createListOfScrollListeners(size);\n\n    RecyclerSpec.onUnbind(\n        mComponentContext,\n        mRecyclerViewWrapper,\n        binder,\n        null,\n        scrollListeners,\n        mAnimator);\n\n    verify(mRecyclerView).setItemAnimator(mAnimator);\n    verify(binder).unbind(mRecyclerView);\n    verify(mRecyclerView, times(size)).removeOnScrollListener(any(OnScrollListener.class));\n    verify(mRecyclerViewWrapper).setOnRefreshListener(null);\n  }\n\n  private static List<RecyclerView.OnScrollListener> createListOfScrollListeners(int size) {\n    List<RecyclerView.OnScrollListener> onScrollListeners = new ArrayList<>(size);\n    for (int i = 0; i < size; i++) {\n      onScrollListeners.add(mock(RecyclerView.OnScrollListener.class));\n    }\n\n    return onScrollListeners;\n  }\n}\n"}
{"label": "test|edit|text|with|text", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.LithoView;\nimport com.facebook.litho.testing.ComponentsRule;\nimport com.facebook.litho.testing.helper.ComponentTestHelper;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n/**\n * Tests {@link EditText} component.\n */\n\n@RunWith(ComponentsTestRunner.class)\npublic class EditTextSpecTest {\n  @Rule\n  public ComponentsRule mComponentsRule = new ComponentsRule();\n\n  private static final String TEXT = \"Hello Components\";\n\n  @Test\n  public void METHOD_NAME() {\n    final ComponentContext c = mComponentsRule.getContext();\n    final LithoView lithoView = ComponentTestHelper.mountComponent(\n        EditText.create(c)\n            .textChangedEventHandler(null)\n            .textSizePx(10)\n            .text(TEXT));\n\n    final android.widget.EditText editText = (android.widget.EditText) lithoView.getChildAt(0);\n    assertThat(editText.getText().toString()).isEqualTo(TEXT);\n    assertThat(editText.getTextSize()).isEqualTo(10);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyBoolean;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport com.facebook.litho.ThreadUtils;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class RecyclerEventsControllerTest {\n\n  private RecyclerViewWrapper mRecyclerViewWrapper;\n  private RecyclerEventsController mRecyclerEventsController;\n\n  @Before\n  public void METHOD_NAME() {\n    mRecyclerEventsController = new RecyclerEventsController();\n    mRecyclerViewWrapper = mock(RecyclerViewWrapper.class);\n    mRecyclerEventsController.setRecyclerViewWrapper(mRecyclerViewWrapper);\n  }\n\n  @After\n  public void teardown() {\n    ThreadUtils.setMainThreadOverride(ThreadUtils.OVERRIDE_DISABLED);\n  }\n\n  @Test\n  public void testClearRefreshingOnNotRefreshingView() {\n    when(mRecyclerViewWrapper.isRefreshing()).thenReturn(false);\n\n    mRecyclerEventsController.clearRefreshing();\n\n    verify(mRecyclerViewWrapper, never()).setRefreshing(anyBoolean());\n    verify(mRecyclerViewWrapper, never()).removeCallbacks(any(Runnable.class));\n    verify(mRecyclerViewWrapper, never()).post(any(Runnable.class));\n  }\n\n  @Test\n  public void testClearRefreshingFromUIThread() {\n    when(mRecyclerViewWrapper.isRefreshing()).thenReturn(true);\n    ThreadUtils.setMainThreadOverride(ThreadUtils.OVERRIDE_MAIN_THREAD_TRUE);\n\n    mRecyclerEventsController.clearRefreshing();\n\n    verify(mRecyclerViewWrapper).setRefreshing(false);\n    verify(mRecyclerViewWrapper, never()).removeCallbacks(any(Runnable.class));\n    verify(mRecyclerViewWrapper, never()).post(any(Runnable.class));\n  }\n\n  @Test\n  public void testClearRefreshingFromNonUIThread() {\n    when(mRecyclerViewWrapper.isRefreshing()).thenReturn(true);\n    ThreadUtils.setMainThreadOverride(ThreadUtils.OVERRIDE_MAIN_THREAD_FALSE);\n\n    mRecyclerEventsController.clearRefreshing();\n\n    verify(mRecyclerViewWrapper, times(1)).removeCallbacks(any(Runnable.class));\n    verify(mRecyclerViewWrapper, times(1)).post(any(Runnable.class));\n  }\n\n  @Test\n  public void testShowRefreshingFromUIThread() {\n    when(mRecyclerViewWrapper.isRefreshing()).thenReturn(false);\n    ThreadUtils.setMainThreadOverride(ThreadUtils.OVERRIDE_MAIN_THREAD_TRUE);\n\n    mRecyclerEventsController.showRefreshing();\n    verify(mRecyclerViewWrapper).setRefreshing(true);\n  }\n\n  @Test\n  public void testShowRefreshingAlreadyRefreshing() {\n    when(mRecyclerViewWrapper.isRefreshing()).thenReturn(true);\n\n    mRecyclerEventsController.showRefreshing();\n    verify(mRecyclerViewWrapper, never()).setRefreshing(anyBoolean());\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.widget;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport android.view.View;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.LithoView;\nimport com.facebook.litho.testing.helper.ComponentTestHelper;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n/**\n * Tests {@link ProgressSpec}\n */\n\n@RunWith(ComponentsTestRunner.class)\npublic class ProgressSpecTest {\n  private ComponentContext mContext;\n\n  @Before\n  public void METHOD_NAME() {\n    mContext = new ComponentContext(RuntimeEnvironment.application);\n  }\n\n  @Test\n  public void testDefault() {\n    LithoView view = getMountedView();\n    assertThat(view.getMeasuredWidth()).isGreaterThan(0);\n    assertThat(view.getMeasuredHeight()).isGreaterThan(0);\n  }\n\n  @Test\n  public void testUnsetSize() {\n    LithoView view = getMountedView();\n\n    view.measure(\n        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),\n        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));\n\n    assertThat(view.getMeasuredWidth()).isEqualTo(ProgressSpec.DEFAULT_SIZE);\n    assertThat(view.getMeasuredHeight()).isEqualTo(ProgressSpec.DEFAULT_SIZE);\n  }\n\n  private LithoView getMountedView() {\n    Progress.Builder progress = Progress.create(mContext);\n\n    return ComponentTestHelper.mountComponent(\n        progress);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static com.facebook.litho.LayoutState.createAndMeasureTreeForComponent;\nimport static com.facebook.litho.SizeSpec.UNSPECIFIED;\nimport static com.facebook.litho.SizeSpec.makeSizeSpec;\nimport static com.facebook.yoga.YogaDirection.LTR;\nimport static com.facebook.yoga.YogaDirection.RTL;\nimport static com.facebook.yoga.YogaEdge.END;\nimport static com.facebook.yoga.YogaEdge.LEFT;\nimport static com.facebook.yoga.YogaEdge.RIGHT;\nimport static com.facebook.yoga.YogaEdge.START;\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.yoga.YogaDirection;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class InternalNodeResolvedPaddingTest {\n  private InternalNode mInternalNode;\n\n  @Before\n  public void METHOD_NAME() {\n    final ComponentContext context = new ComponentContext(RuntimeEnvironment.application);\n    mInternalNode =\n        createAndMeasureTreeForComponent(\n            context,\n            Column.create(context).build(),\n            makeSizeSpec(0, UNSPECIFIED),\n            makeSizeSpec(0, UNSPECIFIED));\n  }\n\n  private static void setDirection(InternalNode node, YogaDirection direction) {\n    node.layoutDirection(direction);\n    node.calculateLayout();\n    node.markLayoutSeen();\n  }\n\n  @Test\n  public void testPaddingLeftWithUndefinedStartEnd() {\n    mInternalNode.paddingPx(LEFT, 10);\n    setDirection(mInternalNode, LTR);\n    assertThat(mInternalNode.getPaddingLeft()).isEqualTo(10);\n  }\n\n  @Test\n  public void testPaddingLeftWithDefinedStart() {\n    mInternalNode.paddingPx(START, 5);\n    mInternalNode.paddingPx(LEFT, 10);\n    setDirection(mInternalNode, LTR);\n    assertThat(mInternalNode.getPaddingLeft()).isEqualTo(5);\n  }\n\n  @Test\n  public void testPaddingLeftWithDefinedEnd() {\n    mInternalNode.paddingPx(END, 5);\n    mInternalNode.paddingPx(LEFT, 10);\n    setDirection(mInternalNode, LTR);\n    assertThat(mInternalNode.getPaddingLeft()).isEqualTo(10);\n  }\n\n  @Test\n  public void testPaddingLeftWithDefinedStartInRtl() {\n    mInternalNode.paddingPx(START, 5);\n    mInternalNode.paddingPx(LEFT, 10);\n    setDirection(mInternalNode, RTL);\n    assertThat(mInternalNode.getPaddingLeft()).isEqualTo(10);\n  }\n\n  @Test\n  public void testPaddingLeftWithDefinedEndInRtl() {\n    mInternalNode.paddingPx(END, 5);\n    mInternalNode.paddingPx(LEFT, 10);\n    setDirection(mInternalNode, RTL);\n    assertThat(mInternalNode.getPaddingLeft()).isEqualTo(5);\n  }\n\n  @Test\n  public void testPaddingRightWithUndefinedStartEnd() {\n    mInternalNode.paddingPx(RIGHT, 10);\n    setDirection(mInternalNode, LTR);\n    assertThat(mInternalNode.getPaddingRight()).isEqualTo(10);\n  }\n\n  @Test\n  public void testPaddingRightWithDefinedStart() {\n    mInternalNode.paddingPx(START, 5);\n    mInternalNode.paddingPx(RIGHT, 10);\n    setDirection(mInternalNode, LTR);\n    assertThat(mInternalNode.getPaddingRight()).isEqualTo(10);\n  }\n\n  @Test\n  public void testPaddingRightWithDefinedEnd() {\n    mInternalNode.paddingPx(END, 5);\n    mInternalNode.paddingPx(RIGHT, 10);\n    setDirection(mInternalNode, LTR);\n    assertThat(mInternalNode.getPaddingRight()).isEqualTo(5);\n  }\n\n  @Test\n  public void testPaddingRightWithDefinedStartInRtl() {\n    mInternalNode.paddingPx(START, 5);\n    mInternalNode.paddingPx(RIGHT, 10);\n    setDirection(mInternalNode, RTL);\n    assertThat(mInternalNode.getPaddingRight()).isEqualTo(5);\n  }\n\n  @Test\n  public void testPaddingRightWithDefinedEndInRtl() {\n    mInternalNode.paddingPx(END, 5);\n    mInternalNode.paddingPx(RIGHT, 10);\n    setDirection(mInternalNode, RTL);\n    assertThat(mInternalNode.getPaddingRight()).isEqualTo(10);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Matchers.anyObject;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.graphics.drawable.Drawable;\nimport com.facebook.litho.displaylist.DisplayList;\nimport com.facebook.litho.displaylist.DisplayListException;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mockito;\n\n/**\n * Test for {@link DisplayListDrawable}\n */\n@RunWith(ComponentsTestRunner.class)\npublic class DisplayListDrawableTest  {\n\n  private DisplayList mDisplayList;\n  private DisplayListContainer mDisplayListContainer;\n  private Drawable mDrawable;\n  private Canvas mCanvas;\n  private Canvas mDlCanvas;\n\n  @Before\n  public void METHOD_NAME() throws DisplayListException {\n    mDisplayList = Mockito.mock(DisplayList.class);\n    mDisplayListContainer = new DisplayListContainer();\n    mDisplayListContainer.setDisplayList(mDisplayList);\n    mDrawable = Mockito.mock(Drawable.class);\n    mCanvas = Mockito.mock(Canvas.class);\n    mDlCanvas = Mockito.mock(Canvas.class);\n    when(mDisplayList.isValid()).thenReturn(true);\n    when(mDrawable.getBounds()).thenReturn(new Rect());\n    when(mDisplayList.start(anyInt(), anyInt())).thenReturn(mDlCanvas);\n  }\n\n  @Test\n  public void testInvalidationSuppression() {\n    DisplayListDrawable displayListDrawable =\n        new DisplayListDrawable(mDrawable, mDisplayListContainer);\n    displayListDrawable.draw(mCanvas);\n    verify(mDrawable, never()).draw((Canvas) anyObject());\n\n    displayListDrawable.suppressInvalidations(true);\n    displayListDrawable.invalidateDrawable(mDrawable);\n    displayListDrawable.suppressInvalidations(false);\n    displayListDrawable.draw(mCanvas);\n    verify(mDrawable, never()).draw((Canvas) anyObject());\n  }\n\n  @Test\n  public void testInvalidation() throws DisplayListException {\n    DisplayListDrawable displayListDrawable =\n        new DisplayListDrawable(mDrawable, mDisplayListContainer);\n    displayListDrawable.draw(mCanvas);\n    verify(mDrawable, never()).draw((Canvas) anyObject());\n\n    displayListDrawable.invalidateDrawable(mDrawable);\n    displayListDrawable.draw(mCanvas);\n    verify(mDisplayList).start(anyInt(), anyInt());\n    verify(mDrawable).draw(mDlCanvas);\n    verify(mDisplayList).end(mDlCanvas);\n    verify(mDisplayList).setBounds(anyInt(), anyInt(), anyInt(), anyInt());\n  }\n\n  @Test\n  public void testMountItemUpdate() {\n    LayoutOutput layoutOutput = ComponentsPools.acquireLayoutOutput();\n    layoutOutput.initDisplayListContainer(\"Test\", false);\n    layoutOutput.setDisplayList(mDisplayList);\n    MountItem mountItem = ComponentsPools.acquireMountItem(null, null, mDrawable, layoutOutput);\n    DisplayListDrawable displayListDrawable = mountItem.getDisplayListDrawable();\n\n    layoutOutput.setDisplayList(null);\n    mountItem.init(null, null, mDrawable, layoutOutput, displayListDrawable);\n\n    displayListDrawable.draw(mCanvas);\n    verify(mDrawable).draw(mCanvas);\n  }\n}\n"}
{"label": "setup", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\nimport static org.mockito.Mockito.mock;\n\nimport android.graphics.Rect;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class TestItemTest {\n  private TestItem mTestItem;\n\n  @Before\n  public void METHOD_NAME() {\n    mTestItem = new TestItem();\n  }\n\n  @Test\n  public void testPositionAndSizeSet() {\n    mTestItem.setBounds(0, 1, 3, 4);\n\n    assertThat(mTestItem.getBounds().left).isEqualTo(0);\n    assertThat(mTestItem.getBounds().top).isEqualTo(1);\n    assertThat(mTestItem.getBounds().right).isEqualTo(3);\n    assertThat(mTestItem.getBounds().bottom).isEqualTo(4);\n  }\n\n  @Test\n  public void testRectBoundsSet() {\n    final Rect bounds = new Rect(0, 1, 3, 4);\n    mTestItem.setBounds(bounds);\n    assertThat(mTestItem.getBounds().left).isEqualTo(0);\n    assertThat(mTestItem.getBounds().top).isEqualTo(1);\n    assertThat(mTestItem.getBounds().right).isEqualTo(3);\n    assertThat(mTestItem.getBounds().bottom).isEqualTo(4);\n  }\n\n  @Test\n  public void testRelease() {\n    final Rect bounds = new Rect(0, 1, 3, 4);\n    mTestItem.setBounds(bounds);\n    mTestItem.setHost(mock(ComponentHost.class));\n\n    mTestItem.release();\n    assertThat(mTestItem.getTextContent()).isEmpty();\n    assertThat(mTestItem.getBounds()).isEqualTo(new Rect());\n    assertThat(mTestItem.getTestKey()).isNull();\n    assertThat(mTestItem.getHost()).isNull();\n  }\n\n  @Test\n  public void testPooling() {\n    final TestItem testItem = ComponentsPools.acquireTestItem();\n\n    final Rect bounds = new Rect(0, 1, 3, 4);\n    testItem.setBounds(bounds);\n    testItem.setHost(mock(ComponentHost.class));\n\n    ComponentsPools.release(testItem);\n    assertThat(testItem.getTextContent()).isEmpty();\n    assertThat(testItem.getBounds()).isEqualTo(new Rect());\n    assertThat(testItem.getTestKey()).isNull();\n    assertThat(testItem.getHost()).isNull();\n  }\n}\n"}
{"label": "set|up", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.testing.subcomponents;\n\nimport static com.facebook.litho.testing.assertj.LithoAssertions.assertThat;\nimport static com.facebook.litho.testing.assertj.SubComponentDeepExtractor.deepSubComponentWith;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assume.assumeThat;\n\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.EventDispatcher;\nimport com.facebook.litho.HasEventDispatcher;\nimport com.facebook.litho.config.ComponentsConfiguration;\nimport com.facebook.litho.testing.ComponentsRule;\nimport com.facebook.litho.testing.assertj.ComponentMatcher;\nimport com.facebook.litho.testing.specmodels.MyGeneric;\nimport com.facebook.litho.testing.specmodels.MyGenericSpec;\nimport com.facebook.litho.testing.specmodels.TestMyGeneric;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class GenericMatcherGenerationTest {\n  @Rule public ComponentsRule mComponentsRule = new ComponentsRule();\n\n  private final GenericProp mGenericProp = new GenericProp();\n\n  @Before\n  public void METHOD_NAME() {\n    assumeThat(\n        \"These tests can only be run in debug mode.\",\n        ComponentsConfiguration.IS_INTERNAL_BUILD,\n        is(true));\n  }\n\n  @Test\n  public void testGenericPropMatching() {\n    final ComponentContext c = mComponentsRule.getContext();\n    final Component component =\n        new MyGeneric<>(new MyGenericSpec()).create(c).genericProp(mGenericProp).build();\n    final ComponentMatcher matcher = TestMyGeneric.matcher(c).genericProp(mGenericProp).build();\n\n    assertThat(c, component).has(deepSubComponentWith(c, matcher));\n  }\n\n  // This is just to fulfill the prop requirements, reusing an existing interface we've got lying\n  // around.\n  public static class GenericProp implements HasEventDispatcher {\n    @Override\n    public EventDispatcher getEventDispatcher() {\n      return null;\n    }\n  }\n}\n"}
{"label": "set|up", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional gr\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\npackage com.facebook.litho.testing.assertj;\n\nimport static com.facebook.litho.testing.assertj.ComponentConditions.typeIs;\nimport static com.facebook.litho.testing.assertj.LithoAssertions.assertThat;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assume.assumeThat;\n\nimport com.facebook.litho.Column;\nimport com.facebook.litho.Component;\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.config.ComponentsConfiguration;\nimport com.facebook.litho.testing.ComponentsRule;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.testing.util.InlineLayoutSpec;\nimport com.facebook.litho.widget.Card;\nimport com.facebook.litho.widget.Text;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\n@RunWith(ComponentsTestRunner.class)\npublic class SubComponentDeepExtractorTest {\n  @Rule public ComponentsRule mComponentsRule = new ComponentsRule();\n\n  private Component mComponent;\n\n  @Before\n  public void METHOD_NAME() {\n    assumeThat(\n        \"These tests can only be run in debug mode.\",\n        ComponentsConfiguration.IS_INTERNAL_BUILD,\n        is(true));\n\n    mComponent =\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            return Column.create(c)\n                .child(Card.create(c).content(Text.create(c).text(\"test\")))\n                .build();\n          }\n        };\n  }\n\n  @Test\n  public void testDeep() {\n    final ComponentContext c = mComponentsRule.getContext();\n    assertThat(c, mComponent)\n        // We don't have a shallow Text component ...\n        .doesNotHave(\n            SubComponentExtractor.subComponentWith(\n                mComponentsRule.getContext(), typeIs(Text.class)))\n        // ... but we do have one deep down.\n        .has(\n            SubComponentDeepExtractor.deepSubComponentWith(\n                mComponentsRule.getContext(), typeIs(Text.class)));\n  }\n}\n"}
{"label": "assume|in|debug|mode", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.testing;\n\nimport static com.facebook.litho.testing.assertj.ComponentConditions.textEquals;\nimport static com.facebook.litho.testing.assertj.SubComponentExtractor.subComponentWith;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.Assume.assumeThat;\n\nimport com.facebook.litho.ComponentContext;\nimport com.facebook.litho.ComponentLayout;\nimport com.facebook.litho.config.ComponentsConfiguration;\nimport com.facebook.litho.testing.assertj.LithoAssertions;\nimport com.facebook.litho.testing.assertj.LithoRepresentation;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport com.facebook.litho.testing.util.InlineLayoutSpec;\nimport com.facebook.litho.widget.Text;\nimport org.assertj.core.api.Assertions;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RuntimeEnvironment;\n\n@RunWith(ComponentsTestRunner.class)\npublic class LithoRepresentationTest {\n\n  @Before\n  public void METHOD_NAME() {\n    assumeThat(\n        \"These tests can only be run in debug mode.\",\n        ComponentsConfiguration.IS_INTERNAL_BUILD,\n        is(true));\n  }\n\n  @Test\n  public void testLithoRepresentation() {\n    final ComponentContext c = new ComponentContext(RuntimeEnvironment.application);\n\n    Assertions.useRepresentation(new LithoRepresentation(c));\n\n    final InlineLayoutSpec layout =\n        new InlineLayoutSpec() {\n          @Override\n          protected ComponentLayout onCreateLayout(ComponentContext c) {\n            return Text.create(c).text(\"Hello, World!\").build();\n          }\n        };\n\n    try {\n      LithoAssertions.assertThat(layout).has(subComponentWith(c, textEquals(\"Doesn't match.\")));\n    } catch (final AssertionError assertionError) {\n      LithoAssertions.assertThat(assertionError)\n          .hasMessageContaining(\"Text{0, 0 - 100, 100 text=\\\"Hello, World!\\\"\");\n    }\n\n    // Verify that resetting the representation in the same\n    Assertions.useDefaultRepresentation();\n\n    try {\n      LithoAssertions.assertThat(layout).has(subComponentWith(c, textEquals(\"Doesn't match.\")));\n    } catch (final AssertionError assertionError) {\n      LithoAssertions.assertThat(assertionError.getMessage())\n          .doesNotContain(\"Text{0, 0 - 100, 100 text=\\\"Hello, World!\\\"\");\n    }\n  }\n}\n"}
{"label": "test|set|static|final", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.testing;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport java.lang.reflect.Field;\nimport org.junit.Test;\n\npublic class ReflectionHelperTest {\n  @Test\n  public void METHOD_NAME() throws NoSuchFieldException, IllegalAccessException {\n    final MyTestClass myTestClass = new MyTestClass();\n    final Field field = MyTestClass.class.getDeclaredField(\"sHiddenField\");\n    ReflectionHelper.setFinalStatic(field, 3);\n\n    assertThat(myTestClass.getHiddenField()).isEqualTo(3);\n  }\n\n  @Test\n  public void testSetStaticFinalConvenience() throws NoSuchFieldException, IllegalAccessException {\n    final MyTestClass myTestClass = new MyTestClass();\n    ReflectionHelper.setFinalStatic(MyTestClass.class, \"sHiddenField\", 2);\n\n    assertThat(myTestClass.getHiddenField()).isEqualTo(2);\n  }\n\n  static class MyTestClass {\n    private static final Integer sHiddenField = 1;\n\n    public int getHiddenField() {\n      return MyTestClass.sHiddenField;\n    }\n  }\n}\n"}
{"label": "set|up", "code": "/*\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.litho.testing.viewtree;\n\nimport static org.assertj.core.api.Java6Assertions.assertThat;\n\nimport android.app.Activity;\nimport android.graphics.drawable.Drawable;\nimport android.view.View;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport com.facebook.litho.it.R;\nimport com.facebook.litho.testing.testrunner.ComponentsTestRunner;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.Robolectric;\n\n/**\n * Tests {@link ViewExtractors}\n */\n@RunWith(ComponentsTestRunner.class)\npublic class ViewExtractorsTest {\n\n  private View mView;\n  private TextView mTextView;\n  private TextView mGoneTextView;\n  private ImageView mImageView;\n  private ImageView mGoneImageView;\n  private Drawable mLithoDrawable;\n\n  @Before\n  public void METHOD_NAME() {\n    final Activity activity = Robolectric.buildActivity(Activity.class).create().get();\n\n    mLithoDrawable = activity.getResources().getDrawable(R.drawable.litho);\n\n    mView = new View(activity);\n\n    mTextView = new TextView(activity);\n    mTextView.setText(\"example\");\n\n    mGoneTextView = new TextView(activity);\n    mGoneTextView.setText(\"gone\");\n    mGoneTextView.setVisibility(View.GONE);\n\n    mImageView = new ImageView(activity);\n    mImageView.setImageDrawable(mLithoDrawable);\n\n    mGoneImageView = new ImageView(activity);\n    mGoneImageView.setImageDrawable(mLithoDrawable);\n    mGoneImageView.setVisibility(View.GONE);\n  }\n\n  @Test\n  public void testGetTextFromTextViewHasTextContent() {\n    assertThat(ViewExtractors.GET_TEXT_FUNCTION.apply(mTextView)).contains(\"example\");\n  }\n\n  @Test\n  public void testGetTextPrintsVisibity() {\n    assertThat(ViewExtractors.GET_TEXT_FUNCTION.apply(mTextView))\n        .contains(\"view is visible\");\n    assertThat(ViewExtractors.GET_TEXT_FUNCTION.apply(mGoneTextView))\n        .contains(\"view is not visible\");\n  }\n\n  @Test\n  public void testViewWithoutText() {\n    assertThat(ViewExtractors.GET_TEXT_FUNCTION.apply(mView))\n        .contains(\"No text found\");\n  }\n\n  @Test\n  public void testGetDrawableOutOfImageView() {\n    assertThat(ViewExtractors.GET_DRAWABLE_FUNCTION.apply(mImageView))\n        .contains(mLithoDrawable.toString());\n  }\n\n  @Test\n  public void testGetDrawablePrintsVisibity() {\n    assertThat(ViewExtractors.GET_DRAWABLE_FUNCTION.apply(mImageView))\n        .contains(\"view is visible\");\n    assertThat(ViewExtractors.GET_DRAWABLE_FUNCTION.apply(mGoneImageView))\n        .contains(\"view is not visible\");\n  }\n\n}\n"}
